"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"[Title page i]","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","1","1","Presents the title page of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00001","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463089","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"[Title page iii]","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","3","3","Presents the title page of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00002","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463064","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"[Copyright notice]","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","4","4","Presents the copyright information for the conference. May include reprint permission information.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00003","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463130","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Table of Contents","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","5","13","Presents the table of contents/splash page of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00004","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463087","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","14","16","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00005","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463128","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Data Showcase Track Co-Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","17","17","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00006","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463097","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Hackathon Co-Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","18","18","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00007","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463104","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Mining Challenge Track Co-Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","19","19","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00008","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463131","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Registered Reports Track Co-Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","20","20","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00009","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463152","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Message from the MSR 2021 Shadow PC and Advisors Co-Chairs","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","21","21","Presents the introductory welcome message from the conference proceedings. May include the conference officers' congratulations to all involved with the conference event and publication of the proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00010","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463102","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Organizing Committee","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","22","23","Provides a listing of current committee members and society officers.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00011","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463071","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Program Committee","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","24","33","Provides a listing of current committee members and society officers.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00012","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463085","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mining Workflows for Anomalous Data Transfers","H. Tu; G. Papadimitriou; M. Kiran; C. Wang; A. Mandal; E. Deelman; T. Menzies","Department of Computer Science, North Carolina State University, Raleigh, USA; University of Southern California, Information Sciences Institute, Marina del Rey, CA, USA; Energy Sciences Network (ESnet), Lawrence Berkeley National Labs, CA, USA; RENCI, University of North Carolina, Chapel Hill, NC, USA; RENCI, University of North Carolina, Chapel Hill, NC, USA; University of Southern California, Information Sciences Institute, Marina del Rey, CA, USA; Department of Computer Science, North Carolina State University, Raleigh, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","1","12","Modern scientific workflows are data-driven and are often executed on distributed, heterogeneous, high-performance computing infrastructures. Anomalies and failures in the work-flow execution cause loss of scientific productivity and inefficient use of the infrastructure. Hence, detecting, diagnosing, and mitigating these anomalies are immensely important for reliable and performant scientific workflows. Since these workflows rely heavily on high-performance network transfers that require strict QoS constraints, accurately detecting anomalous network performance is crucial to ensure reliable and efficient workflow execution. To address this challenge, we have developed X-FLASH, a network anomaly detection tool for faulty TCP workflow transfers. X-FLASH incorporates novel hyperparameter tuning and data mining approaches for improving the performance of the machine learning algorithms to accurately classify the anomalous TCP packets. X-FLASH leverages XGBoost as an ensemble model and couples XGBoost with a sequential optimizer, FLASH, borrowed from search-based Software Engineering to learn the optimal model parameters. X-FLASH found configurations that outperformed the existing approach up to 28%, 29%, and 40% relatively for F-measure, G-score, and recall in less than 30 evaluations. From (1) large improvement and (2) simple tuning, we recommend future research to have additional tuning study as a new standard, at least in the area of scientific workflow anomaly detection.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00013","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463120","Scientific Workflow;TCP Signatures;Anomaly Detection;Hyper-Parameter Tuning;Sequential Optimization","Radio frequency;Tools;Data transfer;Data models;Software;Software reliability;Tuning","","7","","69","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"PSIMiner: A Tool for Mining Rich Abstract Syntax Trees from Code","E. Spirin; E. Bogomolov; V. Kovalenko; T. Bryksin","JetBrains Research, Higher School of Economics, Saint Petersburg, Russia; JetBrains Research, Higher School of Economics, Saint Petersburg, Russia; JetBrains Research, JetBrains N.V., Amsterdam, The Netherlands; JetBrains Research, Saint Petersburg State University, Saint Petersburg, Russia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","13","17","The application of machine learning algorithms to source code has grown in the past years. Since these algorithms are quite sensitive to input data, it is not surprising that researchers experiment with input representations. Nowadays, a popular starting point to represent code is abstract syntax trees (ASTs). Abstract syntax trees have been used for a long time in various software engineering domains, and in particular in IDEs. The API of modern IDEs allows to manipulate and traverse ASTs, resolve references between code elements, etc. Such algorithms can enrich ASTs with new data and therefore may be useful in ML-based code analysis. In this work, we present PSIMiner— a tool for processing PSI trees from the IntelliJ Platform. PSI trees contain code syntax trees as well as functions to work with them, and therefore can be used to enrich code representation using static analysis algorithms of modern IDEs. To showcase this idea, we use our tool to infer types of identifiers in Java ASTs and extend the code2seq model for the method name prediction problem.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00014","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463105","Software Engineering;Data mining;Code representation","Machine learning algorithms;Software algorithms;Static analysis;Tools;Syntactics;Predictive models;Data models","","9","","24","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Comparative Study of Feature Reduction Techniques in Software Change Prediction","R. Malhotra; R. Kapoor; D. Aggarwal; P. Garg","Department of Software Engineering, Delhi Technological University, Delhi, India; Department of Software Engineering, Delhi Technological University, Delhi, India; Department of Software Engineering, Delhi Technological University, Delhi, India; Department of Software Engineering, Delhi Technological University, Delhi, India",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","18","28","Software change prediction (SCP) is the process of identifying change-prone software classes using various structural and quality metrics by developing predictive techniques. The previous studies done in this field strongly confer the correlation between the quality of metrics and the performance of such SCP models. Past SCP studies have also applied different feature reduction (FR) techniques to address issues of high dimensionality, feature irrelevance, and feature repetition. Due to the vast variety of metric suites and FR techniques applied in SCP, there is a need to analyze and compare them. It will help in identifying the most crucial features and the most effective FR techniques. So, in this research, we conduct experiments to compare and contrast 60 Object-Oriented plus 26 Graph-based metrics and 11 state-of-the-art FR techniques previously employed for SCP over a range of 6 Java projects and 3 diverse classifiers. The AUC-ROC measures and statistical tests over experimental SCP models indicate that FR techniques are effective in SCP. Also, there exist significant differences in the performance of the different FR techniques. Furthermore, from this extensive experimentation, we were able to identify a set of the most effective FR techniques and the most crucial metrics which can be used to build effective SCP models.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00015","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463086","Software change prediction;Feature reduction;Object-Oriented metrics;Graph-based metrics;Machine Learning","Measurement;Java;Correlation;Object oriented modeling;Software;Data mining","","3","","42","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Automatic Part-of-Speech Tagging for Security Vulnerability Descriptions","S. Yitagesu; X. Zhang; Z. Feng; X. Li; Z. Xing","College of Intelligence and Computing, Tianjin University, Tianjin, China; College of Intelligence and Computing, Tianjin University, Tianjin, China; College of Intelligence and Computing, Tianjin University, Tianjin, China; College of Intelligence and Computing, Tianjin University, Tianjin, China; Data61 CSIRO, Research School of Computer Science, Australian National University, Australia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","29","40","In this paper, we study the problem of part-of-speech (POS) tagging for security vulnerability descriptions (SVD). In contrast to newswire articles, SVD often contains a high-level natural language description of the text composed of mixed language studded with codes, domain-specific jargon, vague language, and abbreviations. Moreover, training data dedicated to security vulnerability research is not widely available. Existing neural network-based POS tagging has often relied on manually annotated training data or applying natural language processing (NLP) techniques, suffering from two significant drawbacks. The former is extremely time-consuming and requires labor-intensive feature engineering and expertise. The latter is inadequate to identify linguistically-informed words specific to the SVD domain. In this paper, we propose an automatic approach to assign POS tags to tokens in SVD. Our approach uses the character-level representation to automatically extract orthographic features and unsupervised word embeddings to capture meaningful syntactic and semantic regularities from SVD. The character level representations are then concatenated with the word embedding as a combined feature, which is then learned and used to predict the POS tagging. To deal with the issue of the poor availability of annotated security vulnerability data, we implement a finetuning approach. Our approach provides public access to a POS annotated corpus of ~8M tokens, which serves as a training dataset in this domain. Our evaluation results show a significant improvement in accuracy (17.72%-28.22%) of POS tagging in SVD over the current approaches.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00016","Research and Development; National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463114","Fine-Tuning;Part-of-Speech tagging;Unsupervised word embedding;Security vulnerability descriptions","Training;Training data;Tagging;Tools;Syntactics;Feature extraction;Natural language processing","","11","","52","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Identifying Critical Projects via PageRank and Truck Factor","R. -H. Pfeiffer","IT University of Copenhagen, Copenhagen, Denmark",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","41","45","Recently, Google's Open Source team presented the criticality score a metric to assess ""influence and importance"" of a project in an ecosystem from project specific signals, e.g., number of dependents, commit frequency, etc. The community showed mixed reactions towards the score doubting if it can accurately identify critical projects. We share the community's doubts and we hypothesize, that a combination of PageRank (PR) and Truck Factor (TF) can more accurately identify critical projects than Google's current Criticality Score (CS). To verify our hypothesis, we conduct an experiment in which we compute the PR of thousands of projects from various ecosystems, such as, Maven (Java), NPM (JavaScript), PyPI (Python), etc., we compute the TFs of the projects with the highest PR in the respective ecosystems, and we compare these to the scores provided by the Google project. Unlike Google's CS, our approach identifies projects, such as, six and idna from PyPI, com.typesafe:config from Maven, or tap from NPM, as critical projects with high degree of transitive dependents (highest PR) and low amount of core developers (each of them possessing a TF of one).","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00017","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463111","","Measurement;Java;Ecosystems;Software;Internet;Data mining;Software development management","","5","","24","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"An Empirical Study of Developer Discussions on Low-Code Software Development Challenges","M. A. Al Alamin; S. Malakar; G. Uddin; S. Afroz; T. B. Haider; A. Iqbal",University of Calgary; Bangladesh University of Engineering and Technology; University of Calgary; Bangladesh University of Engineering and Technology; Bangladesh University of Engineering and Technology; Bangladesh University of Engineering and Technology,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","46","57","Low-code software development (LCSD) is an emerging paradigm that combines minimal source code with interactive graphical interfaces to promote rapid application development. LCSD aims to democratize application development to software practitioners with diverse backgrounds. Given that LCSD is relatively a new paradigm, it is vital to learn about the challenges developers face during their adoption of LCSD platforms. The online developer forum, Stack Overflow (SO), is popular among software developers to ask for solutions to their technical problems. We observe a growing body of posts in SO with discussions of LCSD platforms. In this paper, we present an empirical study of around 5K SO posts (questions + accepted answers) that contain discussions of nine popular LCSD platforms. We apply topic modeling on the posts to determine the types of topics discussed. We find 13 topics related to LCSD in SO. The 13 topics are grouped into four categories: Customization, Platform Adoption, Database Management, and Third-Party Integration. More than 40% of the questions are about customization, i.e., developers frequently face challenges with customizing user interfaces or services offered by LCSD platforms. The topic ""Dynamic Event Handling"" under the ""Customization"" category is the most popular (in terms of average view counts per question of the topic) as well as the most difficult. It means that developers frequently search for customization solutions such as how to attach dynamic events to a form in low-code UI, yet most (75.9%) of their questions remain without an accepted answer. We manually label 900 questions from the posts to determine the prevalence of the topics’ challenges across LCSD phases. We find that most of the questions are related to the development phase, and low-code developers also face challenges with automated testing. Our study findings offer implications for low-code practitioners, platform providers, educators, and researchers.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00018","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463132","Low-Code;Issue;Challenge;Empirical Study","Visualization;Databases;Tutorials;Documentation;User interfaces;Software;Stakeholders","","46","","63","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Learning Off-By-One Mistakes: An Empirical Study","H. Sellik; O. van Paridon; G. Gousios; M. Aniche","Delft University of Technology, Delft, The Netherlands; Adyen N.V., Amsterdam, The Netherlands; Delft University of Technology, Delft, The Netherlands; Delft University of Technology, Delft, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","58","67","Mistakes in binary conditions are a source of error in many software systems. They happen when developers use, e.g., `<;' or `>' instead of `<;=' or `>='. These boundary mistakes are hard to find and impose manual, labor-intensive work for software developers. While previous research has been proposing solutions to identify errors in boundary conditions, the problem remains open. In this paper, we explore the effectiveness of deep learning models in learning and predicting mistakes in boundary conditions. We train different models on approximately 1.6M examples with faults in different boundary conditions. We achieve a precision of 85% and a recall of 84% on a balanced dataset, but lower numbers in an imbalanced dataset. We also perform tests on 41 real-world boundary condition bugs found from GitHub, where the model shows only a modest performance. Finally, we test the model on a large-scale Java code base from Adyen, our industrial partner. The model reported 36 buggy methods, but none of them were confirmed by developers.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00019","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463090","machine learning for software engineering;deep learning for software engineering;software testing;boundary testing","Deep learning;Java;Analytical models;Adaptation models;Computer bugs;Static analysis;Tools","","3","","36","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"The Secret Life of Hackathon Code Where does it come from and where does it go?","A. Imam; T. Dey; A. Nolte; A. Mockus; J. D. Herbsleb","University of Tartu, Estonia; Lero—the Irish Software Research Centre, University of Limerick, Limerick, Ireland; University of Tartu, Estonia Carnegie Mellon University, Pittsburgh, PA, USA; University of Tennessee, Knoxville, TN, USA; Carnegie Mellon University, Pittsburgh, PA, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","68","79","Background: Hackathons have become popular events for teams to collaborate on projects and develop software prototypes. Most existing research focuses on activities during an event with limited attention to the evolution of the code brought to or created during a hackathon. Aim: We aim to understand the evolution of hackathon-related code, specifically, how much hackathon teams rely on pre-existing code or how much new code they develop during a hackathon. Moreover, we aim to understand if and where that code gets reused, and what factors affect reuse. Method: We collected information about 22,183 hackathon projects from Devpost- a hackathon database - and obtained related code (blobs), authors, and project characteristics from the World of Code. We investigated if code blobs in hackathon projects were created before, during, or after an event by identifying the original blob creation date and author, and also checked if the original author was a hackathon project member. We tracked code reuse by first identifying all commits containing blobs created during an event before determining all projects that contain those commits. Result: While only approximately 9.14% of the code blobs are created during hackathons, this amount is still significant considering time and member constraints of such events. Approximately a third of these code blobs get reused in other projects. The number of associated technologies and the number of participants in a project increase reuse probability. Conclusion: Our study demonstrates to what extent pre-existing code is used and new code is created during a hackathon and how much of it is reused elsewhere afterwards. Our findings help to better understand code reuse as a phenomenon and the role of hackathons in this context and can serve as a starting point for further studies in this area.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00020","Science Foundation Ireland; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463116","Hackathon;Code Reuse;Repository Mining;Commits;Blob Reuse","Databases;Prototypes;Software;Time factors;Data mining","","4","","56","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"gambit – An Open Source Name Disambiguation Tool for Version Control Systems","C. Gote; C. Zingg","Chair of Systems Design, ETH Zurich, Zurich, Switzerland; Chair of Systems Design, ETH Zurich, Zurich, Switzerland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","80","84","Name disambiguation is a complex but highly relevant challenge whenever analysing real-world user data, such as data from version control systems. We propose gambit, a rule-based disambiguation tool that only relies on name and email information. We evaluate its performance against two commonly used algorithms with similar characteristics on manually disambiguated ground-truth data from the Gnome GTK project. Our results show that gambit significantly outperforms both algorithms, achieving an F1 score of 0.985.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00021","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463108","name disambiguation;identity merging;record labeling;rule based algorithm;learning free approach;repository mining;version control systems;Gnome GTK;software engineering;open source","Software algorithms;Tools;Control systems;Software;Data mining","","8","","22","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Escaping the Time Pit: Pitfalls and Guidelines for Using Time-Based Git Data","S. W. Flint; J. Chauhan; R. Dyer","University of Nebraska–Lincoln, Lincoln, NE, USA; University of Nebraska–Lincoln, Lincoln, NE, USA; University of Nebraska–Lincoln, Lincoln, NE, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","85","96","Many software engineering research papers rely on time-based data (e.g., commit timestamps, issue report creation/update/close dates, release dates). Like most real-world data however, time-based data is often dirty. To date, there are no studies that quantify how frequently such data is used by the software engineering research community, or investigate sources of and quantify how often such data is dirty. Depending on the research task and method used, including such dirty data could affect the research results. This paper presents the first survey of papers that utilize time-based data, published in the Mining Software Repositories (MSR) conference series. Out of the 690 technical track and data papers published in MSR 2004–2020, we saw at least 35% of papers utilized time-based data. We then used the Boa and Software Heritage infrastructures to help identify and quantify several sources of dirty commit timestamp data. Finally we provide guidelines/best practices for researchers utilizing time-based data from Git repositories.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00022","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463113","time-based;survey","Training;Out of order;Filtering;Machine learning;Tools;Software;Data mining","","9","","39","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Attention-based model for predicting question relatedness on Stack Overflow","J. Pei; Y. Wu; Z. Qin; Y. Cong; J. Guan","South China University of Technology, Guangzhou, China; South China University of Technology, Guangzhou, China; South China University of Technology, Guangzhou, China; South China University of Technology, Guangzhou, China; Research Institute of SCUT in Yangjiang, Yangjiang, China",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","97","107","Stack Overflow is one of the most popular Programming Community-based Question Answering (PCQA) websites that has attracted more and more users in recent years. When users raise or inquire questions in Stack Overflow, providing related questions can help them solve problems. Although there are many approaches based on deep learning that can automatically predict the relatedness between questions, those approaches are limited since interaction information between two questions may be lost. In this paper, we adopt the deep learning technique, propose an Attention-based Sentence pair Interaction Model (ASIM) to predict the relatedness between questions on Stack Overflow automatically. We adopt the attention mechanism to capture the semantic interaction information between the questions. Besides, we have pre-trained and released word embeddings specific to the software engineering domain for this task, which may also help other related tasks. The experiment results demonstrate that ASIM has made significant improvement over the baseline approaches in Precision, Recall, and Micro-F1 evaluation metrics, achieving state-of-the-art performance in this task. Our model also performs well in the duplicate question detection task of AskUbuntu, which is a similar but different task, proving its generalization and robustness.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00023","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463123","Stack Overflow;Question Relatedness;Deep Learning;Attention Mechanism;Word Embeddings","Deep learning;Measurement;Semantics;Predictive models;Programming;Knowledge discovery;Software","","10","","35","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"An Empirical Study on the Usage of BERT Models for Code Completion","M. Ciniselli; N. Cooper; L. Pascarella; D. Poshyvanyk; M. Di Penta; G. Bavota","SEART @ Software Institute, Università della Svizzera italiana (USI), Switzerland; SEMERU @ Computer Science Department, William and Mary, USA; SEART @ Software Institute, Università della Svizzera italiana (USI), Switzerland; SEMERU @ Computer Science Department, William and Mary, USA; Department of Engineering, University of Sannio, Italy; SEART @ Software Institute, Università della Svizzera italiana (USI), Switzerland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","108","119","Code completion is one of the main features of modern Integrated Development Environments (IDEs). Its objective is to speed up code writing by predicting the next code token(s) the developer is likely to write. Research in this area has substantially bolstered the predictive performance of these techniques. However, the support to developers is still limited to the prediction of the next few tokens to type. In this work, we take a step further in this direction by presenting a large-scale empirical study aimed at exploring the capabilities of state-of-the-art deep learning (DL) models in supporting code completion at different granularity levels, including single tokens, one or multiple entire statements, up to entire code blocks (e.g., the iterated block of a for loop). To this aim, we train and test several adapted variants of the recently proposed RoBERTa model, and evaluate its predictions from several perspectives, including: (i) metrics usually adopted when assessing DL generative models (i.e., BLEU score and Levenshtein distance); (ii) the percentage of perfect predictions (i.e., the predicted code snippets that match those written by developers); and (iii) the ""semantic"" equivalence of the generated code as compared to the one written by developers. The achieved results show that BERT models represent a viable solution for code completion, with perfect predictions ranging from ~7%, obtained when asking the model to guess entire blocks, up to ~58%, reached in the simpler scenario of few tokens masked from the same code statement.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00024","European Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463129","Code Completion;BERT","Deep learning;Adaptation models;Java;Bit error rate;Semantics;Predictive models;Software","","51","","59","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On Improving Deep Learning Trace Analysis with System Call Arguments","Q. Fournier; D. Aloise; S. V. Azhari; F. Tetreault","Polytechnique Montréal, Quebec; Polytechnique Montréal, Quebec; Ciena, Ottawa; Ciena, Ottawa",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","120","130","Kernel traces are sequences of low-level events comprising a name and multiple arguments, including a timestamp, a process id, and a return value, depending on the event. Their analysis helps uncover intrusions, identify bugs, and find latency causes. However, their effectiveness is hindered by omitting the event arguments. To remedy this limitation, we introduce a general approach to learning a representation of the event names along with their arguments using both embedding and encoding. The proposed method is readily applicable to most neural networks and is task-agnostic. The benefit is quantified by conducting an ablation study on three groups of arguments: call-related, process-related, and time-related. Experiments were conducted on a novel web request dataset and validated on a second dataset collected on pre-production servers by Ciena, our partnering company. By leveraging additional information, we were able to increase the performance of two widely-used neural networks, an LSTM and a Transformer, by up to 11.3% on two unsupervised language modelling tasks. Such tasks may be used to detect anomalies, pre-train neural networks to improve their performance, and extract a contextual representation of the events.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00025","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463093","Tracing;Machine Learning;Deep Learning","Deep learning;Neural networks;Computer bugs;Companies;Software;Encoding;Servers","","6","","31","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"An Empirical Study of OSS-Fuzz Bugs","Z. Y. Ding; C. Le Goues","Motional (work done at Carnegie Mellon University), Pittsburgh, USA; School of Computer Science, Carnegie Mellon University, Pittsburgh, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","131","142","Continuous fuzzing is an increasingly popular technique for automated quality and security assurance. Google maintains OSS-Fuzz: a continuous fuzzing service for open source software. We conduct the first empirical study of OSS-Fuzz, analyzing 23,907 bugs found in 316 projects. We examine the characteristics of fuzzer-found faults, the lifecycles of such faults, and the evolution of fuzzing campaigns over time. We find that OSS-Fuzz is often effective at quickly finding bugs, and developers are often quick to patch them. However, flaky bugs, timeouts, and out of memory errors are problematic, people rarely file CVEs for security vulnerabilities, and fuzzing campaigns often exhibit punctuated equilibria, where developers might be surprised by large spikes in bugs found. Our findings have implications on future fuzzing research and practice.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00026","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463112","fuzzing;continuous fuzzing;OSS-Fuzz","Computer bugs;Fuzzing;Internet;Security;Data mining;Open source software","","27","","95","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"An Exploratory Study of Log Placement Recommendation in an Enterprise System","J. Cândido; J. Haesen; M. Aniche; A. van Deursen","Department of Software Technology, Delft University of Technology, The Netherlands; Adyen N.V., The Netherlands; Department of Software Technology, Delft University of Technology, The Netherlands; Department of Software Technology, Delft University of Technology, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","143","154","Logging is a development practice that plays an important role in the operations and monitoring of complex systems. Developers place log statements in the source code and use log data to understand how the system behaves in production. Unfortunately, anticipating where to log during development is challenging. Previous studies show the feasibility of leveraging machine learning to recommend log placement despite the data imbalance since logging is a fraction of the overall code base. However, it remains unknown how those techniques apply to an industry setting, and little is known about the effect of imbalanced data and sampling techniques. In this paper, we study the log placement problem in the code base of Adyen, a large-scale payment company. We analyze 34,526 Java files and 309,527 methods that sum up +2M SLOC. We systematically measure the effectiveness of five models based on code metrics, explore the effect of sampling techniques, understand which features models consider to be relevant for the prediction, and evaluate whether we can exploit 388,086 methods from 29 Apache projects to learn where to log in an industry setting. Our best performing model achieves 79% of balanced accuracy, 81% of precision, 60% of recall. While sampling techniques improve recall, they penalize precision at a prohibitive cost. Experiments with open-source data yield under-performing models over Adyen's test set; nevertheless, they are useful due to their low rate of false positives. Our supporting scripts and tools are available to the community.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00027","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463118","Log Placement;Log Recommendation;Logging Practices;Supervised Learning","Industries;Measurement;Training;Biological system modeling;Training data;Machine learning;Production","","8","","50","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On the Naturalness and Localness of Software Logs","S. Gholamian; P. A. S. Ward","University of Waterloo, Waterloo, ON, Canada; University of Waterloo, Waterloo, ON, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","155","166","Logs are an essential part of the development and maintenance of large and complex software systems as they contain rich information pertaining to the dynamic content and state of the system. As such, developers and practitioners rely heavily on the logs to monitor their systems. In parallel, the increasing volume and scale of the logs, due to the growing complexity of modern software systems, renders the traditional way of manual log inspection insurmountable. Consequently, to handle large volumes of logs efficiently and effectively, various prior research aims to automate the analysis of log files. Thus, in this paper, we begin with the hypothesis that log files are natural and local and these attributes can be applied for automating log analysis tasks. We guide our research with six research questions with regards to the naturalness and localness of the log files, and present a case study on anomaly detection and introduce a tool for anomaly detection, called ANALOG, to demonstrate how our new findings facilitate the automated analysis of logs.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00028","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463117","software systems;logging statements;log files;entropy;natural language processing;naturalness;localness;natural language processing (NLP);anomaly detection","Manuals;Tools;Maintenance engineering;Inspection;Software systems;Complexity theory;Task analysis","","5","","78","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Automatically Selecting Follow-up Questions for Deficient Bug Reports","M. M. Imran; A. Ciborowska; K. Damevski","Virginia Commonwealth University, Richmond, Virginia, U.S.A.; Virginia Commonwealth University, Richmond, Virginia, U.S.A.; Virginia Commonwealth University, Richmond, Virginia, U.S.A.",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","167","178","The availability of quality information in bug reports that are created daily by software users is key to rapidly fixing software faults. Improving incomplete or deficient bug reports, which are numerous in many popular and actively developed open source software projects, can make software maintenance more effective and improve software quality. In this paper, we propose a system that addresses the problem of bug report incompleteness by automatically posing follow-up questions, intended to elicit answers that add value and provide missing information to a bug report. Our system is based on selecting follow-up questions from a large corpus of already posted follow-up questions on GitHub. To estimate the best follow-up question for a specific deficient bug report we combine two metrics based on: 1) the compatibility of a follow-up question to a specific bug report; and 2) the utility the expected answer to the follow-up question would provide to the deficient bug report. Evaluation of our system, based on a manually annotated held-out data set, indicates improved performance over a set of simple and ablation baselines. A survey of software developers confirms the held-out set evaluation result that about half of the selected follow-up questions are considered valid. The survey also indicates that the valid follow-up questions are useful and can provide new information to a bug report most of the time, and are specific to a bug report some of the time.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00029","National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463135","follow-up questions;bug reporting;bug triage","Measurement;Software maintenance;Computer bugs;Software quality;Data mining;Open source software;Software development management","","2","","51","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Self-Admitted Technical Debt in R Packages: An Exploratory Study","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","179","189","Self-Admitted Technical Debt (SATD) is a particular case of Technical Debt (TD) where developers explicitly acknowledge their sub-optimal implementation decisions. Though previous studies have demonstrated that SATD is common in software projects and negatively impacts their maintenance, they have mostly approached software systems coded in traditional object-oriented programming (OOP), such as Java, C++ or .NET. This paper studies SATD in R packages, and reports results of a three-part study. The first part mined more than 500 R packages available on GitHub, and manually analysed more than 164k of comments to generate a dataset. The second part administered a crowd-sourcing to analyse the quality of the extracted comments, while the third part conducted a survey to address developers' perspectives regarding SATD comments. The main findings indicate that a large amount of outdated code is left commented, with SATD accounting for about 3% of comments. Code Debt was the most common type, but there were also traces of Algorithm Debt, and there is a considerable amount of comments dedicated to circumventing CRAN checks. Moreover, package authors seldom address the SATD they encounter and often add it as self-reminders.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00030","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463082","Self-Admitted Technical Debt;Mining Software Repositories;Empirical Software Engineering;R Programming","Java;Natural languages;Focusing;Documentation;Maintenance engineering;Inspection;Software systems","","5","","27","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Architecture Smells and Pareto Principle: A Preliminary Empirical Exploration","A. -M. Chaniotaki; T. Sharma","Athens University of Economics & Business, Athens, Greece; Siemens Technology, Charlotte, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","190","194","Architecture smells represent violations of best practices recommended for software architecture that adversely impact various quality attributes of a software system. Though architecture quality is considered very important by the software engineering community, architecture refactoring, given involved high risk and effort, is often avoided by software development teams. In this paper, we empirically explore the properties of architecture smells in the context of the Pareto principle. We investigate the degree of adherence of architecture smell occurrences to the Pareto principle and explore the influence of other related factors i.e., programming language and size of the repositories. To this end, we analyzed 750 Java and 361 C# repositories containing more than 50 million lines of code to detect seven kinds of architecture smells. We found that approximately 45% of the Java repositories follow the Pareto principle. Moreover, C# repositories show significantly higher adherence (66%) to the principle than the repositories written in Java. Our results indicate that the size of the repositories shows a low negative correlation with the Pareto categories. The results imply that software development teams can figure out a few vital components suffering from architecture smells by carrying out the Pareto analysis. It will allow them to optimize their efforts towards making their software architecture quality better.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00031","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463110","Architecture smells;Pareto principle","Java;Computer languages;Correlation;Software architecture;Computer architecture;Software systems;C# languages","","8","","41","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Technical Debt in the Peer-Review Documentation of R Packages: a rOpenSci Case Study","Z. Codabux; M. Vidoni; F. H. Fard",University of Saskatchewan; RMIT University; University of British Columbia,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","195","206","Context: Technical Debt (TD) is a metaphor used to describe code that is ""not quite right."" Although TD studies have gained momentum, TD has yet to be studied as thoroughly in non-Object-Oriented (OO) or scientific software such as R. R is a multi-paradigm programming language, whose popularity in data science and statistical applications has amplified in recent years. Due to R’s inherent ability to expand through user-contributed packages, several community-led organizations were created to organize and peer-review packages in a concerted effort to increase their quality. Nonetheless, it is well-known that most R users do not have a technical programming background, being from multiple disciplines. Objective: The goal of this study is to investigate TD in the documentation of the peer-review of R packages led by rOpenSci. Method: We collected over 5,000 comments from 157 packages that had been reviewed and approved to be published at rOpenSci. We manually analyzed a sample dataset of these comments posted by package authors, editors of rOpenSci, and reviewers during the review process to investigate the types of TD present in these reviews. Results: The findings of our study include (i) a taxonomy of TD derived from our analysis of the peer-reviews (ii) documentation debt as being the most prevalent type of debt (iii) different user roles are concerned with different types of TD. For instance, reviewers tend to report some types of TD more than other roles, and the types of TD they report are different from those reported by the authors of a package. Conclusion: TD analysis in scientific software or peer-review is almost non-existent. Our study is a pioneer but within the context of R packages. However, our findings can serve as a starting point for replication studies, given our public datasets, to perform similar analyses in other scientific software or to investigate the rationale behind our findings.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00032","Natural Sciences and Engineering Research Council of Canada; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463083","Technical Debt;R Programming;rOpensci;Technical Debt Taxonomy;Mining Software Repositories","Computer languages;Taxonomy;Documentation;Organizations;Programming;Data science;Software","","6","","66","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"How Java Programmers Test Exceptional Behavior","D. Marcilio; C. A. Furia","USI Università della Svizzera italiana, Lugano, Switzerland; USI Università della Svizzera italiana, Lugano, Switzerland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","207","218","Exceptions often signal faulty or undesired behavior; hence, high-quality test suites should also target exceptional behavior. This paper is a large-scale study of exceptional tests-which exercise exceptional behavior-in 1 157 open-source Java projects hosted on GitHub. We analyzed JUnit exceptional tests to understand what kinds of exceptions are more frequently tested, what coding patterns are used, and how features of a project, such as its size and number of contributors, correlate to the characteristics of its exceptional tests. We found that exceptional tests are only 13% of all tests, but tend to be larger than other tests on average; unchecked exceptions are tested twice as frequently as checked ones; 42% of all exceptional tests use try/catch blocks and usually are larger than those using other idioms; and bigger projects with more contributors tend to have more exceptional tests written using different styles. The paper also zeroes in on several detailed examples involving some of the largest analyzed projects, which refine the empirical results with qualitative evidence. The study's findings, and the capabilities of the tool we developed to analyze exceptional tests, suggest several implications for the practice of software development and for follow-up empirical studies.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00033","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463092","","Java;Tools;Encoding;Data mining;Open source software;Software development management","","7","","127","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"A Replication Study on the Usability of Code Vocabulary in Predicting Flaky Tests","G. Haben; S. Habchi; M. Papadakis; M. Cordy; Y. Le Traon",University of Luxembourg; University of Luxembourg; University of Luxembourg; University of Luxembourg; University of Luxembourg,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","219","229","Industrial reports indicate that flaky tests are one of the primary concerns of software testing mainly due to the false signals they provide. To deal with this issue, researchers have developed tools and techniques aiming at (automatically) identifying flaky tests with encouraging results. However, to reach industrial adoption and practice, these techniques need to be replicated and evaluated extensively on multiple datasets, occasions and settings. In view of this, we perform a replication study of a recently proposed method that predicts flaky tests based on their vocabulary. We thus replicate the original study on three different dimensions. First, we replicate the approach on the same subjects as in the original study but using a different evaluation methodology, i.e., we adopt a time-sensitive selection of training and test sets to better reflect the envisioned use case. Second, we consolidate the findings of the initial study by building a new dataset of 837 flaky tests from 9 projects in a different programming language, i.e., Python while the original study was in Java, which comforts the generalisability of the results. Third, we propose an extension to the original approach by experimenting with different features extracted from the Code Under Test. We find that a more robust validation consistently decreases performance on the reported results of the original study, but, fortunately, the model remains capable to decently predict flaky tests. We find re-assuring results that the vocabulary-based models can also be used to predict test flakiness in Python. Finally, we find that the information lying in the Code Under Test has a limited impact on the performance of the vocabulary-based models.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00034","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463145","Software testing;regression testing;flakiness","Training;Software testing;Vocabulary;Java;Predictive models;Tools;Feature extraction","","27","","39","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Leveraging Models to Reduce Test Cases in Software Repositories","G. Gharachorlu; N. Sumner","Simon Fraser University, Canada; Simon Fraser University, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","230","241","Given a failing test case, test case reduction yields a smaller test case that reproduces the failure. This process can be time consuming due to repeated trial and error with smaller test cases. Current techniques speed up reduction by only exploring syntactically valid candidates, but they still spend significant effort on semantically invalid candidates. In this paper, we propose a model-guided approach to speed up test case reduction. The approach trains a model of semantic properties driven by syntactic test case properties. By using this model, we can skip testing even syntactically valid test case candidates that are unlikely to succeed. We evaluate this model-guided reduction on a suite of 14 large fuzzer-generated C test cases from the bug repositories of two well-known C compilers, GCC and Clang. Our results show that with an average precision of 77%, we can decrease the number of removal trials by 14% to 61%. We observe a 30% geomean improvement in reduction time over the state of the art technique while preserving similar reduction power.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00035","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463100","test case reduction;semantic validity;machine learning;compilation errors","Computer bugs;Semantics;Syntactics;Predictive models;Feature extraction;Software;Data mining","","4","","29","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Which contributions count? Analysis of attribution in open source","J. -G. Young; A. Casari; K. McLaughlin; M. Z. Trujillo; L. Hébert-Dufresne; J. P. Bagrow","University of Vermont, Burlington, VT, USA; Open Source Programs Office, Google, Kirkland, WA, USA; Open Source Programs Office, Google, Sydney, New South Wales, Australia; University of Vermont, Burlington, VT, USA; University of Vermont, Burlington, VT, USA; University of Vermont, Burlington, VT, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","242","253","Open source software projects usually acknowledge contributions with text files, websites, and other idiosyncratic methods. These data sources are hard to mine, which is why contributorship is most frequently measured through changes to repositories, such as commits, pushes, or patches. Recently, some open source projects have taken to recording contributor actions with standardized systems; this opens up a unique opportunity to understand how community-generated notions of contributorship map onto codebases as the measure of contribution. Here, we characterize contributor acknowledgment models in open source by analyzing thousands of projects that use a model called All Contributors to acknowledge diverse contributions like outreach, finance, infrastructure, and community management. We analyze the life cycle of projects through this model’s lens and contrast its representation of contributorship with the picture given by other methods of acknowledgment, including GitHub’s top committers indicator and contributions derived from actions taken on the platform. We find that community-generated systems of contribution acknowledgment make work like idea generation or bug finding more visible, which generates a more extensive picture of collaboration. Further, we find that models requiring explicit attribution lead to more clearly defined boundaries around what is and is not a contribution.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00036","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463079","open source software;contributions;teams;github","Analytical models;Conferences;Taxonomy;Refining;Computer bugs;Finance;Data mining","","16","","53","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On the Use of Dependabot Security Pull Requests","M. Alfadel; D. E. Costa; E. Shihab; M. Mkhallalati","Data-driven Analysis of Software (DAS) Lab, Concordia University, Montreal, Canada; Data-driven Analysis of Software (DAS) Lab, Concordia University, Montreal, Canada; Data-driven Analysis of Software (DAS) Lab, Concordia University, Montreal, Canada; Data-driven Analysis of Software (DAS) Lab, Concordia University, Montreal, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","254","265","Vulnerable dependencies are a major problem in modern software development. As software projects depend on multiple external dependencies, developers struggle to constantly track and check for corresponding security vulnerabilities that affect their project dependencies. To help mitigate this issue, Dependabot has been created, a bot that issues pull-requests to automatically update vulnerable dependencies. However, little is known about the degree to which developers adopt Dependabot to help them update vulnerable dependencies.In this paper, we investigate 2,904 JavaScript open-source GitHub projects that subscribed to Dependabot. Our results show that the vast majority (65.42%) of the created security-related pull-requests are accepted, often merged within a day. Through manual analysis, we identify 7 main reasons for Dependabot security pull-requests not being merged, mostly related to concurrent modifications of the affected dependencies rather than Dependabot failures. Interestingly, only 3.2% of the manually examined pull-requests suffered from build breakages. Finally, we model the time it takes to merge a Dependabot security pull-request using characteristics from projects, the fixed vulnerabilities and issued pull requests. Our model reveals 5 significant features to explain merge times, e.g., projects with relevant experience with Dependabot security pull-requests are most likely associated with rapid merges. Surprisingly, the severity of the dependency vulnerability and the potential risk of breaking changes are not strongly associated with the merge time. To the best of our knowledge, this study is the first to evaluate how developers receive Dependabot’s security contributions. Our findings indicate that Dependabot provides an effective platform for increasing awareness of dependency vulnerabilities and helps developers mitigate vulnerability threats in JavaScript projects.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00037","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463148","Dependabot;pull request;dependency;security vulnerability","Manuals;Security;Data mining;Open source software;Software development management","","24","","74","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"S3M: Siamese Stack (Trace) Similarity Measure","A. Khvorov; R. Vasiliev; G. Chernishev; I. M. Rodrigues; D. Koznov; N. Povarov","JetBrains, ITMO University, Saint-Petersburg, Russia; JetBrains, Saint-Petersburg, Russia; Saint-Petersburg State University, Saint-Petersburg, Russia; Polytechnique Montreal, Montreal, Canada; Saint-Petersburg State University, Saint-Petersburg, Russia; JetBrains, Saint-Petersburg, Russia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","266","270","Automatic crash reporting systems have become a de-facto standard in software development. These systems monitor target software, and if a crash occurs they send details to a backend application. Later on, these reports are aggregated and used in the development process to 1) understand whether it is a new or an existing issue, 2) assign these bugs to appropriate developers, and 3) gain a general overview of the application’s bug landscape. The efficiency of report aggregation and subsequent operations heavily depends on the quality of the report similarity metric. However, a distinctive feature of this kind of report is that no textual input from the user (i.e., bug description) is available: it contains only stack trace information.In this paper, we present S3M (""extreme"") — the first approach to computing stack trace similarity based on deep learning. It is based on a siamese architecture that uses a biLSTM encoder and a fully-connected classifier to compute similarity. Our experiments demonstrate the superiority of our approach over the state-of-the-art on both open-sourced data and a private JetBrains dataset. Additionally, we review the impact of stack trace trimming on the quality of the results.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00038","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463141","Crash Report;Stack Trace;Deduplication;Automatic Crash Reporting;Deep Learning","Deep learning;Computer bugs;Computer architecture;Software;Software measurement;Data mining;Standards","","8","","28","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Challenges in Developing Desktop Web Apps: a Study of Stack Overflow and GitHub","G. L. Scoccia; P. Migliarini; M. Autili","DISIM, University of L’Aquila, L’Aquila, Italy; DISIM, University of L’Aquila, L’Aquila, Italy; DISIM, University of L’Aquila, L’Aquila, Italy",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","271","282","Software companies have an interest in reaching the maximum amount of potential customers while, at the same time, providing a frictionless experience. Desktop web app frameworks are promising in this respect, allowing developers and companies to reuse existing code and knowledge of web applications to create cross-platform apps integrated with native APIs. Despite their growing popularity, existing challenges in employing these technologies have not been documented, and it is hard for individuals and companies to weigh benefits and pros against drawbacks and cons.In this paper, we address this issue by investigating the challenges that developers frequently experience when adopting desktop web app frameworks. To achieve this goal, we mine and apply topic modeling techniques to a dataset of 10,822 Stack Overflow posts related to the development of desktop web applications. Analyzing the resulting topics, we found that: i) developers often experience issues regarding the build and deployment processes for multiple platforms; ii) reusing existing libraries and development tools in the context of desktop applications is often cumbersome; iii) it is hard to solve issues that arise when interacting with native APIs. Furthermore, we confirm our finding by providing evidence that the identified issues are also present in the issue reports of 453 open-source applications publicly hosted on GitHub.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00039","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463138","Web technologies;Desktop apps;Stack Over-flow;GitHub;Topic modeling","Knowledge engineering;Companies;Tools;Libraries;Data mining;Open source software;Software development management","","7","","45","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Studying the Change Histories of Stack Overflow and GitHub Snippets","S. S. Manes; O. Baysal","School of Computer Science, Carleton University, Ottawa, Canada; School of Computer Science, Carleton University, Ottawa, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","283","294","Stack Overflow is a popular Q&A forum for soft-ware developers, providing a large number of copyable code snippets. While GitHub is a collaborative development platform, developers often reuse Stack Overflow code in their GitHub projects. These snippets get revised or edited on each platform. In this work, we study Stack Overflow posts and the code snippets that are reused from these posts in GitHub projects. We investigate and compare the change history of SO snippets with the change history of GitHub snippets. We have applied a stratified random sampling when mining 440,000 GitHub projects to create a dataset representing the change history of the reused snippets; this dataset contains 22,900 GitHub projects, 33,765 Stack Overflow references mapped to 4,634 Stack Overflow posts, and a total of 73,322 commits.We analyze the evolution patterns of snippets on each platform, compare key trends and explore the co-change of these snippets. Our results demonstrate that 76% of snippets evolve on Stack Overflow, while only 22% of the reused code snippets evolve in GitHub. Stack Overflow snippets undergo fewer and smaller changes compared to their evolving counterparts on GitHub. The evolution of snippets on both platforms is driven by the original author of the content. Finally, we found that a small percentage of snippets is co-changing across two platforms, while snippets in GitHub and Stack Overflow evolve independently of one another.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00040","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463143","Code snippets;change history;evolution;Stack Overflow;GitHub;time series;co-change;code reuse","Buildings;Collaboration;Market research;Software;History;Data mining;Software development management","","8","","55","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"TNM: A Tool for Mining of Socio-Technical Data from Git Repositories","N. Sviridov; M. Evtikhiev; V. Kovalenko","Department of IT and Programming, ITMO University, St. Petersburg, Russia; Intelligent Collaboration Tools Lab, JetBrains Research, St. Petersburg, Russia; Intelligent Collaboration Tools Lab, JetBrains Research, Amsterdam, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","295","299","Networks of collaboration between engineers are reflected in traces of developers' activity in version control systems (VCSs). Extracting data from Git repositories is an essential task for researchers and practitioners working on socio-technical analysis, but it requires substantial engineering work. With increasing interest in analysing socio-technical data and applying it in practice, there are no flexible and easily reusable tools to retrieve socio-technical information from VCSs. With no common reusable toolkit existing for this task, the burden of mining diverts the focus of researchers from their core research questions.In this paper, we present TNM-an open-source tool for mining socio-technical data from Git repositories. TNM is fast, flexible, and easily extensible.TNM is available on GitHub: https://github.com/JetBrains-Research/tnm.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00041","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463084","","Collaboration;Tools;Control systems;Data mining;Task analysis;Open source software","","5","","40","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mining the ROS ecosystem for Green Architectural Tactics in Robotics and an Empirical Evaluation","I. Malavolta; K. Chinnappan; S. Swanborn; G. A. Lewis; P. Lago","Vrije Universiteit Amsterdam, The Netherlands; Vrije Universiteit Amsterdam, The Netherlands; Vrije Universiteit Amsterdam, The Netherlands; Software Engineering Institute, Carnegie Mellon University, USA; Vrije Universiteit Amsterdam, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","300","311","In today's world, reducing energy consumption should be the goal for any organization and any system, including robotics software systems. However, state of the practice in robotics software development focuses primarily on achieving functionality and performance, with minimal recognition of energy-efficiency as a driving software quality. The goal of this paper is to identify, synthesize, and empirically evaluate architectural tactics for energy-efficiency applied by practitioners in real robotics projects. Four tactics were identified by mining software repository techniques applied to the ROS ecosystem. The tactics were evaluated via experimentation on a real, commodity robotics system. Results show that the application of green architectural tactics tends to largely improve the energy-efficiency of the robot (7.9% energy savings when all tactics are applied) and that the movement strategy and the physical environment where the robot operates strongly influence how energy is consumed by the robot.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00042","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463098","Robotics software;Software Architecture;Energy efficient software","Green products;Ecosystems;Mission critical systems;Software quality;Organizations;Software systems;Energy efficiency","","10","","75","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mining API Interactions to Analyze Software Revisions for the Evolution of Energy Consumption","A. Schuler; G. Kotsis","Department of Telecooperation, Johannes Kepler University, Linz, Austria; Department of Telecooperation, Johannes Kepler University, Linz, Austria",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","312","316","With the widespread use and adoption of mobile platforms like Android a new software quality concern has emerged - energy consumption. However, developing energy-efficient software and applications requires knowledge and like-wise proper tooling to support mobile developers. To this aim, we present an approach to examine the energy evolution of software revisions based on their API interactions. The approach stems from the assumption that the utilization of an API has direct implications on the energy being consumed during runtime. Based on an empirical evaluation, we show initial results that API interactions serve as a flexible, lightweight, and effective way to compare software revisions regarding their energy evolution. Given our initial results we envision that in future using our approach mobile developers will be able to gain insights on the energy implications of changes in source code in the course of the software development life-cycle.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00043","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463126","software energy profiling;energy consumption;dynamic program analysis;API mining","Measurement;Energy consumption;Runtime;Focusing;Software quality;Software;Energy efficiency","","","","27","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Googling for Software Development: What Developers Search For and What They Find","A. Hora","Department of Computer Science, Universidade Federal de Minas Gerais (UFMG), Belo Horizonte, Brazil",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","317","328","Developers often search for software resources on the web. In practice, instead of going directly to websites (e.g., Stack Overflow), they rely on search engines (e.g., Google). Despite this being a common activity, we are not yet aware of what developers search from the perspective of popular software development websites and what search results are returned. With this knowledge, we can understand real-world queries, developers’ needs, and the query impact on the search results. In this paper, we provide an empirical study to understand what developers search on the web and what they find. We assess 1.3M queries to popular programming websites and we perform thousands of queries on Google to explore search results. We find that (i) developers’ queries typically start with keywords (e.g., Python, Android, etc.), are short (3 words), tend to omit functional words, and are similar among each other; (ii) minor changes to queries do not largely affect the Google search results, however, some cosmetic changes may have a non-negligible impact; and (iii) search results are dominated by Stack Overflow, but YouTube is also a relevant source nowadays. We conclude by presenting detailed implications for researchers and developers.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00044","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463121","Software Development;Web Search;Google Search;Empirical Study","Search engines;Programming;Software;Internet;Data mining;Python","","21","","68","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Fast and Memory-Efficient Neural Code Completion","A. Svyatkovskiy; S. Lee; A. Hadjitofi; M. Riechert; J. V. Franco; M. Allamanis",Microsoft; University of Oxford; University of Edinburgh; Microsoft; Microsoft; Microsoft,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","329","340","Code completion is one of the most widely used features of modern integrated development environments (IDEs). While deep learning has made significant progress in the statistical prediction of source code, state-of-the-art neural network models consume hundreds of megabytes of memory, bloating the development environment. We address this in two steps: first we present a modular neural framework for code completion. This allows us to explore the design space and evaluate different techniques. Second, within this framework we design a novel reranking neural completion model that combines static analysis with granular token encodings. The best neural reranking model consumes just 6 MB of RAM, - 19x less than previous models - computes a single completion in 8 ms, and achieves 90% accuracy in its top five suggestions.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00045","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463109","code completion;deep learning;API completion","Deep learning;Computational modeling;Neural networks;Random access memory;Static analysis;Predictive models;Software","","48","","44","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Identifying Versions of Libraries used in Stack Overflow Code Snippets","A. Zerouali; C. Velázquez-Rodríguez; C. De Roover","Vrije Universiteit Brussel, Brussels, Belgium; Vrije Universiteit Brussel, Brussels, Belgium; Vrije Universiteit Brussel, Brussels, Belgium",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","341","345","Stack Overflow is a popular question and answer platform where developers share technical issues in the hope of receiving answers with potential solutions. The latter may include code snippets making use of library versions that have long since been succeeded by newer ones. Other developers finding such a snippet at a later point in time may be unaware of its outdatedness unless mentioned in a comment. Furthermore, it can be difficult to integrate the snippet without knowing the exact version of the library it is referencing. In this paper, we propose an automated approach to identifying ranges of Maven library versions that might have been used in a Java snippet on Stack Overflow. We use a prototype implementation of the approach to assess the overall outdatedness of Stack Overflow snippets with respect to the latest version of each referenced library available from Maven. We found a considerable number of snippets that use outdated library versions, which suggests that developers should be careful when adopting solutions from Stack Overflow.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00046","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463142","Stack Overflow;software libraries;method calls;Maven","Java;Prototypes;Libraries;Software;Data mining","","5","","9","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Can I Solve It? Identifying APIs Required to Complete OSS Tasks","F. Santos; I. Wiese; B. Trinkenreich; I. Steinmacher; A. Sarma; M. A. Gerosa","Northern Arizona University, USA; Universidade Tecnológica Federal do Paraná, Brazil; Northern Arizona University, USA; Northern Arizona University, USA; Oregon State University, USA; Northern Arizona University, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","346","257","Open Source Software projects add labels to open issues to help contributors choose tasks. However, manually labeling issues is time-consuming and error-prone. Current automatic approaches for creating labels are mostly limited to classifying issues as a bug/non-bug. In this paper, we investigate the feasibility and relevance of labeling issues with the domain of the APIs required to complete the tasks. We leverage the issues’ description and the project history to build prediction models, which resulted in precision up to 82% and recall up to 97.8%. We also ran a user study (n=74) to assess these labels’ relevancy to potential contributors. The results show that the labels were useful to participants in choosing tasks, and the API-domain labels were selected more often than the existing architecture-based labels. Our results can inspire the creation of tools to automatically label issues, helping developers to find tasks that better match their skills.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00047","National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463078","API identification;Labelling;Tagging;Skills;Multi-Label Classification;Mining Software Repositories;Case Study","Industries;Tools;Predictive models;Prediction algorithms;Data models;Labeling;History","","15","","63","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Data Balancing Improves Self-Admitted Technical Debt Detection","M. Sridharan; M. Mantyla; L. Rantala; M. Claes","M3S, ITEE, University of Oulu, Oulu, Finland; M3S, ITEE, University of Oulu, Oulu, Finland; M3S, ITEE, University of Oulu, Oulu, Finland; M3S, ITEE, University of Oulu, Oulu, Finland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","358","368","A high imbalance exists between technical debt and non-technical debt source code comments. Such imbalance affects Self-Admitted Technical Debt (SATD) detection performance, and existing literature lacks empirical evidence on the choice of balancing technique. In this work, we evaluate the impact of multiple balancing techniques, including Data level, Classifier level, and Hybrid, for SATD detection in Within-Project and Cross-Project setup. Our results show that the Data level balancing technique SMOTE or Classifier level Ensemble approaches Random Forest or XGBoost are reasonable choices depending on whether the goal is to maximize Precision, Recall, F1, or AUC-ROC. We compared our best-performing model with the previous SATD detection benchmark (cost-sensitive Convolution Neural Network). Interestingly the top-performing XGBoost with SMOTE sampling improved the Within-project F1 score by 10% but fell short in Cross-Project set up by 9%. This supports the higher generalization capability of deep learning in Cross-Project SATD detection, yet while working within individual projects, classical machine learning algorithms can deliver better performance. We also evaluate and quantify the impact of duplicate source code comments in SATD detection performance. Finally, we employ SHAP and discuss the interpreted SATD features. We have included the replication package1 and shared a web-based SATD prediction tool2 with the balancing techniques in this study.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00048","Academy of Finland; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463080","Self-Admitted Technical Debt;data imbalance;classification;data sampling techniques;cost-sensitive technique;ensemble techniques","Deep learning;Machine learning algorithms;Transfer learning;Neural networks;Focusing;Tools;Software","","6","","44","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"JITLine: A Simpler, Better, Faster, Finer-grained Just-In-Time Defect Prediction","C. Pornprasit; C. K. Tantithamthavorn","Monash University, Melbourne, Australia; Monash University, Melbourne, Australia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","369","379","A Just-In-Time (JIT) defect prediction model is a classifier to predict if a commit is defect-introducing. Recently, CC2Vec-a deep learning approach for Just-In-Time defect prediction-has been proposed. However, CC2Vec requires the whole dataset (i.e., training + testing) for model training, assuming that all unlabelled testing datasets would be available beforehand, which does not follow the key principles of just-in-time defect predictions. Our replication study shows that, after excluding the testing dataset for model training, the F-measure of CC2Vec is decreased by 38.5% for OpenStack and 45.7% for Qt, highlighting the negative impact of excluding the testing dataset for Just-In-Time defect prediction. In addition, CC2Vec cannot perform fine-grained predictions at the line level (i.e., which lines are most risky for a given commit). In this paper, we propose JITLine-a Just-In-Time defect prediction approach for predicting defect-introducing commits and identifying lines that are associated with that defect-introducing commit (i.e., defective lines). Through a case study of 37,524 commits from OpenStack and Qt, we find that our JITLine approach is at least 26%-38% more accurate (F-measure), 17%-51% more cost-effective (PCI@20%LOC), 70-100 times faster than the state-of-the-art approaches (i.e., CC2Vec and DeepJIT) and the fine-grained predictions at the line level by our approach are 133%-150% more accurate (Top-10 Accuracy) than the baseline NLP approach. Therefore, our JITLine approach may help practitioners to better prioritize defect-introducing commits and better identify defective lines.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00049","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463103","Software Quality Assurance;Just In Time Defect Prediction;Explainable AI","Training;Deep learning;Computational modeling;Predictive models;Software;Data mining;Artificial intelligence","","74","","44","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Rollback Edit Inconsistencies in Developer Forum","S. Mondal; G. Uddin; C. K. Roy","University of Saskatchewan, Canada; University of Calgary, Canada; University of Saskatchewan, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","380","391","The success of developer forums like Stack Overflow (SO) depends on the participation of users and the quality of shared knowledge. SO allows its users to suggest edits to improve the quality of the posts (i.e., questions and answers). Such posts can be rolled back to an earlier version when the current version of the post with the suggested edit does not satisfy the user. However, subjectivity bias in deciding either an edit is satisfactory or not could introduce inconsistencies in the rollback edits. For example, while a user may accept the formatting of a method name (e.g., getActivity()) as a code term, another user may reject it. Such bias in rollback edits could be detrimental and demotivating to the users whose suggested edits were rolled back. This problem is compounded due to the absence of specific guidelines and tools to support consistency across users on their rollback actions. To mitigate this problem, we investigate the inconsistencies in the rollback editing process of SO and make three contributions. First, we identify eight inconsistency types in rollback edits through a qualitative analysis of 777 rollback edits in 382 questions and 395 answers. Second, we determine the impact of the eight rollback inconsistencies by surveying 44 software developers. More than 80% of the study participants find our produced catalogue of rollback inconsistencies to be detrimental to the post quality. Third, we develop a suite of algorithms to detect the eight rollback inconsistencies. The algorithms offer more than 95% accuracy and thus can be used to automatically but reliably inform users in SO of the prevalence of inconsistencies in their suggested edits and rollback actions.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00050","Natural Sciences and Engineering Research Council of Canada; Canada First Research Excellence Fund; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463153","Stack Overflow;rollback edits;inconsistency","Software algorithms;Tools;Software;Encoding;Reliability;Data mining;Standards","","2","","52","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"What Code Is Deliberately Excluded from Test Coverage and Why?","A. Hora","Department of Computer Science, Universidade Federal de Minas Gerais (UFMG), Belo Horizonte, Brazil",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","392","402","Test coverage is largely used to assess test effectiveness. In practice, not all code is equally important for coverage analysis, for instance, code that will not be executed during tests is irrelevant and can actually harm the analysis. Some coverage tools provide support for code exclusion from coverage reports, however, we are not yet aware of what code tends to be excluded nor the reasons behind it. This can support the creation of more accurate coverage reports and reveal novel and harmful usage cases. In this paper, we provide the first empirical study to understand code exclusion practices in test coverage. We mine 55 Python projects and assess commit messages and code comments to detect rationales for exclusions. We find that (1) over 1/3 of the projects perform deliberate coverage exclusion; (2) 75% of the code are already created using the exclusion feature, while 25% add it over time; (3) developers exclude non-runnable, debug-only, and defensive code, but also platform-specific and conditional importing; and (4) most code is excluded because it is already untested, low-level, or complex. Finally, we discuss implications to improve coverage analysis and shed light on the existence of biased coverage reports.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00051","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463122","Software Testing;Test Coverage;Software Evolution;Software Maintenance;Software Repository Mining","Fault diagnosis;Java;Tools;Feature extraction;Software;Proposals;Data mining","","5","","38","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Waiting around or job half-done? Sentiment in self-admitted technical debt","G. Fucci; N. Cassee; F. Zampetti; N. Novielli; A. Serebrenik; M. Di Penta","University of Sannio, Italy; Eindhoven University of Technology, The Netherlands; University of Sannio, Italy; University of Bari, Italy; Eindhoven University of Technology, The Netherlands; University of Sannio, Italy",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","403","414","Self-Admitted Technical Debt (SATD) represents the admission, made through source code comments or other channels, of portions of a program being poorly implemented, containing provisional solutions or, in general, simply being not ready yet. To better understand developers' habits in SATD annotation, and possibly support their exploitation in tool support, this paper provides an in-depth analysis of the content provided in SATD comments, and the expressed sentiment. We manually inspect and classify 1038 instances from an existing dataset, grouping them along a taxonomy composed of 41 categories (of which 9 top-level ones), identifying their sentiment, and the presence of external references such as author names or issue IDs. Results of our study indicate that (i) the SATD content is crosscutting along life-cycle dimensions identified in previous work, (ii) comments related to functional problems or on-hold SATD are generally more negative than poor implementation choices or partially implemented functionality, and (iii) despite observations from previous literature, only a minority of SATD comments leverage external references.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00052","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463101","Self-Admitted technical debt;sentiment analysis;empirical study","Annotations;Taxonomy;Computer bugs;Documentation;Tools;Software;Data mining","","9","","26","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mining DEV for social and technical insights about software development","M. Papoutsoglou; J. Wachs; G. M. Kapitsaki","University of Cyprus, Cyprus; Vienna University of Economics and Business, Austria; University of Cyprus, Cyprus",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","415","419","Software developers are social creatures: they communicate, collaborate, and promote their work in a variety of channels. Twitter, GitHub, Stack Overflow, and other platforms offer developers opportunities to network and exchange ideas. Researchers analyze content on these sites to learn about trends and topics in software engineering. However, insight mined from the text of Stack Overflow questions or GitHub issues is highly focused on detailed and technical aspects of software development. In this paper, we present a relatively new online community for software developers called DEV. On DEV users write long-form posts about their experiences, preferences, and working life in software, zooming out from specific issues and files to reflect on broader topics. About 50,000 users have posted over 140,000 articles related to software development. In this work, we describe the content of posts on DEV using a topic model, showing that developers discuss a rich variety and mixture of social and technical aspects of software development. We show that developers use DEV to promote themselves and their work: 83% link their profiles to their GitHub profiles and 56% to their Twitter profiles. 14% of users pin specific GitHub repos in their profiles. We argue that DEV is emerging as an important hub for software developers, and a valuable source of insight for researchers to complement data from platforms like GitHub and Stack Overflow.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00053","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463115","Developers;social networks;human factors;topic modeling;GitHub;DEV","Social networking (online);Blogs;Market research;Software;Pins;Data mining;Software development management","","5","","40","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"How Do Software Developers Use GitHub Actions to Automate Their Workflows?","T. Kinsman; M. Wessel; M. A. Gerosa; C. Treude","University of Adelaide, Australia; University of São Paulo, Brazil; Northern Arizona University, USA; University of Adelaide, Australia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","420","431","Automated tools are frequently used in social coding repositories to perform repetitive activities that are part of the distributed software development process. Recently, GitHub introduced GitHub Actions, a feature providing automated work-flows for repository maintainers. Although several Actions have been built and used by practitioners, relatively little has been done to evaluate them. Understanding and anticipating the effects of adopting such kind of technology is important for planning and management. Our research is the first to investigate how developers use Actions and how several activity indicators change after their adoption. Our results indicate that, although only a small subset of repositories adopted GitHub Actions to date, there is a positive perception of the technology. Our findings also indicate that the adoption of GitHub Actions increases the number of monthly rejected pull requests and decreases the monthly number of commits on merged pull requests. These results are especially relevant for practitioners to understand and prevent undesirable effects on their projects.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00054","Coordenação de Aperfeiçoamento de Pessoal de Nível Superior; Australian Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463074","GitHub Actions;GitHub Bots;Automated work-flow;Regression Discontinuity Design","Tools;Encoding;Data models;Planning;Data mining;IEEE activities;Open source software","","46","","37","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Practitioners’ Perceptions of the Goals and Visual Explanations of Defect Prediction Models","J. Jiarpakdee; C. K. Tantithamthavorn; J. Grundy","Monash University, Melbourne, Australia; Monash University, Melbourne, Australia; Monash University, Melbourne, Australia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","432","443","Software defect prediction models are classifiers that are constructed from historical software data. Such software defect prediction models have been proposed to help developers optimize the limited Software Quality Assurance (SQA) resources and help managers develop SQA plans. Prior studies have different goals for their defect prediction models and use different techniques for generating visual explanations of their models. Yet, it is unclear what are the practitioners' perceptions of (1) these defect prediction model goals, and (2) the model-agnostic techniques used to visualize these models. We conducted a qualitative survey to investigate practitioners' perceptions of the goals of defect prediction models and the model-agnostic techniques used to generate visual explanations of defect prediction models. We found that (1) 82%-84% of the respondents perceived that the three goals of defect prediction models are useful; (2) LIME is the most preferred technique for understanding the most important characteristics that contributed to a prediction of a file, while ANOVA/VarImp is the second most preferred technique for understanding the characteristics that are associated with software defects in the past. Our findings highlight the significance of investigating how to improve the understanding of defect prediction models and their predictions. Hence, model-agnostic techniques from explainable AI domain may help practitioners to understand defect prediction models and their predictions.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00055","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463073","Software Quality Assurance;Defect Prediction;Explainable AI;Software Analytics","Visualization;Analytical models;Privacy;Software quality;Predictive models;Data models;Data mining","","45","","54","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Does Code Review Promote Conformance? A Study of OpenStack Patches","P. Sri-iesaranusorn; R. G. Kula; T. Ishio","Nara Institute of Science and Technology, Nara, Japan; Nara Institute of Science and Technology, Nara, Japan; Nara Institute of Science and Technology, Nara, Japan",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","444","448","Code Review plays a crucial role in software quality, by allowing reviewers to discuss and critique any new patches before they can be successfully integrated into the project code. Yet, it is unsure the extent to which coding pattern changes (i.e., repetitive code) from when a patch is first submitted and when the decision is made (i.e., during the review process). In this study, we revisit coding patterns in code reviews, aiming to analyze whether or not the coding pattern changes during the review process. Comparing prior submitted patches, we measure differences in coding pattern between pre-review (i.e., patch before the review) and post-review (i.e., patch after a review) from 27,736 reviewed OpenStack patches. Results show that patches after review, tend to conform to similar coding patterns of accepted patches, compared to when they were first submitted. We also find that accepted patches do have similar coding patterns to prior accepted patches. Our study reveals insights into the review process, supporting the potential for automated tool support for newcomers and lays the groundwork for work into understanding conformance and how it makes for an efficient code review process.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00056","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463066","Code review;Naturalness;Language model","Software quality;Tools;Encoding;Data mining","","","","13","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Revisiting Dockerfiles in Open Source Software Over Time","K. Eng; A. Hindle","Department of Computing Science, University of Alberta, Edmonton, Canada; Department of Computing Science, University of Alberta, Edmonton, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","449","459","Docker is becoming ubiquitous with containerization for developing and deploying applications. Previous studies have analyzed Dockerfiles that are used to create container images in order to better understand how to improve Docker tooling. These studies obtain Dockerfiles using either Docker Hub or Github. In this paper, we revisit the findings of previous studies using the largest set of Dockerfiles known to date with over 9.4 million unique Dockerfiles found in the World of Code infrastructure spanning from 2013-2020. We contribute a historical view of the Dockerfile format by analyzing the Docker engine changelogs and use the history to enhance our analysis of Dockerfiles. We also reconfirm previous findings of a downward trend in using OS images and an upward trend of using language images. As well, we reconfirm that Dockerfile smell counts are slightly decreasing meaning that Dockerfile authors are likely getting better at following best practices. Based on these findings, it indicates that previous analyses from prior works have been correct in many of their findings and their suggestions to build better tools for Docker image creation are further substantiated.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00057","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463072","Git;GitHub;Docker","Education;Containers;Tools;Market research;Cognition;History;Data mining","","14","","50","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Characterising the Knowledge about Primitive Variables in Java Code Comments","M. Alghamdi; S. Hayashi; T. Kobayashi; C. Treude","School of Computer Science, The University of Adelaide, Adelaide, Australia; School of Computing, Tokyo Institute of Technology, Tokyo, Japan; School of Computing, Tokyo Institute of Technology, Tokyo, Japan; School of Computer Science, The University of Adelaide, Adelaide, Australia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","460","470","Primitive types are fundamental components available in any programming language, which serve as the building blocks of data manipulation. Understanding the role of these types in source code is essential to write software. Little work has been conducted on how often these variables are documented in code comments and what types of knowledge the comments provide about variables of primitive types. In this paper, we present an approach for detecting primitive variables and their description in comments using lexical matching and advanced matching. We evaluate our approaches by comparing the lexical and advanced matching performance in terms of recall, precision, and F-score, against 600 manually annotated variables from a sample of GitHub projects. The performance of our advanced approach based on F-score was superior compared to lexical matching, 0.986 and 0.942, respectively. We then create a taxonomy of the types of knowledge contained in these comments about variables of primitive types. Our study showed that developers usually documented the variables' identifiers of a numeric data type with their purpose (69.16%) and concept (72.75%) more than the variables' identifiers of type String which were less documented with purpose (61.14%) and concept (55.46%). Our findings characterise the current state of the practice of documenting primitive variables and point at areas that are often not well documented, such as the meaning of boolean variables or the purpose of fields and local variables.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00058","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463146","Knowledge;documentation;variables;source code comments","Java;Computer languages;Taxonomy;Software;Data mining;Software development management","","3","","37","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Predicting Design Impactful Changes in Modern Code Review: A Large-Scale Empirical Study","A. Uchôa; C. Barbosa; D. Coutinho; W. Oizumi; W. K. G. Assunção; S. R. Vergilio; J. A. Pereira; A. Oliveira; A. Garcia","Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Computer Science Department, Federal University of Paraná (UFPR), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil; Informatics Department, Pontifical Catholic University of Rio de Janeiro (PUC-Rio), Brazil",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","471","482","Companies have adopted modern code review as a key technique for continuously monitoring and improving the quality of software changes. One of the main motivations for this is the early detection of design impactful changes, to prevent that design-degrading ones prevail after each code review. Even though design degradation symptoms often lead to changes' rejections, practices of modern code review alone are actually not sufficient to avoid or mitigate design decay. Software design degrades whenever one or more symptoms of poor structural decisions, usually represented by smells, end up being introduced by a change. Design degradation may be related to both technical and social aspects in collaborative code reviews. Unfortunately, there is no study that investigates if code review stakeholders, e.g, reviewers, could benefit from approaches to distinguish and predict design impactful changes with technical and/or social aspects. By analyzing 57,498 reviewed code changes from seven open-source systems, we report an investigation on prediction of design impactful changes in modern code review. We evaluated the use of six ML algorithms to predict design impactful changes. We also extracted and assessed 41 different features based on both social and technical aspects. Our results show that Random Forest and Gradient Boosting are the best algorithms. We also observed that the use of technical features results in more precise predictions. However, the use of social features alone, which are available even before the code review starts (e.g., for team managers or change assigners), also leads to highly-accurate prediction. Therefore social and/or technical prediction models can be used to support further design inspection of suspicious changes early in a code review process. Finally, we provide an enriched dataset that allows researchers to investigate the context behind design impactful changes during the code review process.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00059","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463137","design changes;code review;machine learning","Degradation;Software design;Predictive models;Inspection;Prediction algorithms;Feature extraction;Stakeholders","","21","","76","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mining Energy-Related Practices in Robotics Software","M. Albonico; I. Malavolta; G. Pinto; E. Guzman; K. Chinnappan; P. Lago","Technological Federal University of Paraná - UTFPR, Brazil; Vrije Universiteit Amsterdam, The Netherlands; Federal University of Pará, Brazil; Vrije Universiteit Amsterdam, The Netherlands; Vrije Universiteit Amsterdam, The Netherlands; Vrije Universiteit Amsterdam, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","483","494","Robots are becoming more and more commonplace in many industry settings. This successful adoption can be partly attributed to (1) their increasingly affordable cost and (2) the possibility of developing intelligent, software-driven robots. Unfortunately, robotics software consumes significant amounts of energy. Moreover, robots are often battery-driven, meaning that even a small energy improvement can help reduce its energy footprint and increase its autonomy and user experience.In this paper, we study the Robot Operating System (ROS) ecosystem, the de-facto standard for developing and prototyping robotics software. We analyze 527 energy-related data points (including commits, pull-requests and issues on ROS-related repositories, ROS-related questions on StackOverflow, ROS Discourse, ROS Answers and the official ROS Wiki).Our results include a quantification of the interest of roboticists on software energy efficiency, 10 recurrent causes and 14 solutions of energy-related issues, and their implied trade-offs with respect to other quality attributes. Those contributions support roboticists and researchers towards having energy-efficient software in future robotics projects.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00060","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463077","Energy consumption;Robotics;Software engeineering;Mining software repository","Industries;Service robots;Operating systems;Ecosystems;Software;Energy efficiency;Data mining","","13","","53","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On the Rise and Fall of Simple Stupid Bugs: a Life-Cycle Analysis of SStuBs","B. Mosolygó; N. Vándor; G. Antal; P. Hegedűs","Department of Software Engineering, University of Szeged, Szeged, Hungary; Department of Software Engineering, University of Szeged, Szeged, Hungary; Department of Software Engineering, University of Szeged, Szeged, Hungary; MTA-SZTE Research Group on Artificial Intelligence, ELKH, Szeged, Hungary",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","495","499","Bug detection and prevention is one of the most important goals of software quality assurance. Nowadays, many of the major problems faced by developers can be detected or even fixed fully or partially with automatic tools. However, recent works explored that there exists a substantial amount of simple yet very annoying errors in code-bases, which are easy to fix, but hard to detect as they do not hinder the functionality of the given product in a major way. Programmers introduce such errors accidentally, mostly due to inattention.Using the ManySStuBs4J dataset, which contains many simple, stupid bugs, found in GitHub repositories written in the Java programming language, we investigated the history of such bugs. We were interested in properties such as: How long do such bugs stay unnoticed in code-bases? Whether they are typically fixed by the same developer who introduced them? Are they introduced with the addition of new code or caused more by careless modification of existing code? We found that most of such stupid bugs lurk in the code for a long time before they get removed. We noticed that the developer who made the mistake seems to find a solution faster, however less then half of SStuBs are fixed by the same person. We also examined PMD's performance when to came to flagging lines containing SStuBs, and found that similarly to SpotBugs, it is insufficient when it comes to finding these types of errors. Examining the life-cycle of such bugs allows us to better understand their nature and adjust our development processes and quality assurance methods to better support avoiding them.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00061","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463136","Bug life-cycle;bug fixing times;code history analysis;SStuBs","Java;Computer languages;Quality assurance;Computer bugs;Software quality;Tools;History","","4","","18","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"How Effective is Continuous Integration in Indicating Single-Statement Bugs?","J. Latendresse; R. Abdalkareem; D. Elias Costa; E. Shihab","Concordia University, Montreal, Canada; Queen’s University, Kingston, Canada; Concordia University, Montreal, Canada; Concordia University, Montreal, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","500","504","Continuous Integration (CI) is the process of automatically compiling, building, and testing code changes in the hope of catching bugs as they are introduced into the code base. With bug fixing being a core and increasingly costly task in software development, the community has adopted CI to mitigate this issue and improve the quality of their software products. Bug fixing is a core task in software development and becomes increasingly costly over time. However, little is known about how effective CI is at detecting simple, single-statement bugs.In this paper, we analyze the effectiveness of CI in 14 popular open source Java-based projects to warn about 318 single-statement bugs (SStuBs). We analyze the build status at the commits that introduce SStuBs and before the SStuBs were fixed. We then investigate how often CI indicates the presence of these bugs, through test failure. Our results show that only 2% of the commits that introduced SStuBs have builds with failed tests and 7.5% of builds before the fix reported test failures. Upon close manual inspection, we found that none of the failed builds actually captured SStuBs, indicating that CI is not the right medium to capture the SStuBs we studied. Our results suggest that developers should not rely on CI to catch SStuBs or increase their CI pipeline coverage to detect single-statement bugs.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00062","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463134","","Computer languages;Computer bugs;Pipelines;Manuals;Tools;Inspection;Software","","2","","12","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Applying CodeBERT for Automated Program Repair of Java Simple Bugs","E. Mashhadi; H. Hemmati","Schulich School of Engineering, University of Calgary, Calgary, Canada; Schulich School of Engineering, University of Calgary, Calgary, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","505","509","Software debugging, and program repair are among the most time-consuming and labor-intensive tasks in software engineering that would benefit a lot from automation. In this paper, we propose a novel automated program repair approach based on CodeBERT, which is a transformer-based neural architecture pre-trained on large corpus of source code. We fine-tune our model on the ManySStuBs4J small and large datasets to automatically generate the fix codes. The results show that our technique accurately predicts the fixed codes implemented by the developers in 19-72% of the cases, depending on the type of datasets, in less than a second per bug. We also observe that our method can generate varied-length fixes (short and long) and can fix different types of bugs, even if only a few instances of those types of bugs exists in the training dataset.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00063","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463106","Program repair;CodeBERT;Sequence to sequence learning;Transformers;Deep learning","Training;Java;Automation;Computer bugs;Computer architecture;Maintenance engineering;Data mining","","89","","23","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"A large-scale study on human-cloned changes for automated program repair","F. Madeiral; T. Durieux","KTH Royal Institute of Technology, Stockholm, Sweden; KTH Royal Institute of Technology, Stockholm, Sweden",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","510","514","Research in automatic program repair has shown that real bugs can be automatically fixed. However, there are several challenges involved in such a task that are not yet fully addressed. As an example, consider that a test-suite-based repair tool performs a change in a program to fix a bug spotted by a failing test case, but then the same or another test case fails. This could mean that the change is a partial fix for the bug or that another bug was manifested. However, the repair tool discards the change and possibly performs other repair attempts. One might wonder if the applied change should be also applied in other locations in the program so that the bug is fully fixed. In this paper, we are interested in investigating the extent of bug fix changes being cloned by developers within patches. Our goal is to investigate the need of multi-location repair by using identical or similar changes in identical or similar contexts. To do so, we analyzed 3,049 multi-hunk patches from the ManySStuBs4J dataset, which is a large dataset of single statement bug fix changes. We found out that 68 % of the multi-hunk patches contain at least one change clone group. Moreover, most of these patches (70 %) are strictly-cloned ones, which are patches fully composed of changes belonging to one single change clone group. Finally, most of the strictly-cloned patches (89 %) contain change clones with identical changes, independently of their contexts. We conclude that automated solutions for creating patches composed of identical or similar changes can be useful for fixing bugs.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00064","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463147","automatic program repair;patch;change clone","Computer bugs;Cloning;Maintenance engineering;Tools;Software;Data mining;Task analysis","","3","","13","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Mea culpa: How developers fix their own simple bugs differently from other developers","W. Zhu; M. W. Godfrey","David R. Cheriton School of Computer Science, University of Waterloo, Waterloo, Ontario, Canada; David R. Cheriton School of Computer Science, University of Waterloo, Waterloo, Ontario, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","515","519","In this work, we study how the authorship of code affects bug-fixing commits using the SStuBs dataset, a collection of single-statement bug fix changes in popular Java Maven projects. More specifically, we study the differences in characteristics between simple bug fixes by the original author - that is, the developer who submitted the bug-inducing commit - and by different developers (i.e., non-authors). Our study shows that nearly half (i.e., 44.3%) of simple bugs are fixed by a different developer. We found that bug fixes by the original author and by different developers differed qualitatively and quantitatively. We observed that bug-fixing time by authors is much shorter than that of other developers. We also found that bug-fixing commits by authors tended to be larger in size and scope, and address multiple issues, whereas bug-fixing commits by other developers tended to be smaller and more focused on the bug itself. Future research can further study the different patterns in bug-fixing and create more tailored tools based on the developer's needs.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00065","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463125","SStuBs;bug fix;empirical software engineering;Open source;Open source development","Java;Computer bugs;Tools;Writing;Software;Data mining","","2","","11","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"PySStuBs: Characterizing Single-Statement Bugs in Popular Open-Source Python Projects","A. V. Kamienski; L. Palechor; C. -P. Bezemer; A. Hindle","University of Alberta, Edmonton, Alberta, Canada; University of Alberta, Edmonton, Alberta, Canada; University of Alberta, Edmonton, Alberta, Canada; University of Alberta, Edmonton, Alberta, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","520","524","Single-statement bugs (SStuBs) can have a severe impact on developer productivity. Despite usually being simple and not offering much of a challenge to fix, these bugs may still disturb a developer’s workflow and waste precious development time. However, few studies have paid attention to these simple bugs, focusing instead on bugs of any size and complexity. In this study, we explore the occurrence of SStuBs in some of the most popular open-source Python projects on GitHub, while also characterizing their patterns and distribution. We further compare these bugs to SStuBs found in a previous study on Java Maven projects. We find that these Python projects have different SStuB patterns than the ones in Java Maven projects and identify 7 new SStuB patterns. Our results may help uncover the importance of understanding these bugs for the Python programming language, and how developers can handle them more effectively.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00066","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463149","Single-statement bugs;Python;open-source projects","Productivity;Java;Computer bugs;Focusing;Syntactics;Dynamic programming;Open source software","","10","","22","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On the Distribution of ""Simple Stupid Bugs"" in Unit Test Files: An Exploratory Study","A. Peruma; C. D. Newman","Rochester Institute of Technology, Rochester, New York, USA; Rochester Institute of Technology, Rochester, New York, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","525","529","A key aspect of ensuring the quality of a software system is the practice of unit testing. Through unit tests, developers verify the correctness of production source code, thereby verifying the system’s intended behavior under test. However, unit test code is subject to issues, ranging from bugs in the code to poor test case design (i.e., test smells). In this study, we compare and contrast the occurrences of a type of single-statement-bug-fix known as ""simple stupid bugs"" (SStuBs) in test and non-test (i.e., production) files in popular open-source Java Maven projects. Our results show that SStuBs occur more frequently in non-test files than in test files, with most fix-related code associated with assertion statements in test files. Further, most test files exhibiting SStuBs also exhibit test smells. We envision our findings enabling tool vendors to better support developers in improving the maintenance of test suites.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00067","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463091","Mining Software Repositories;Unit Tests;Bugs;Simple Stupid Bugs;Test Smells","Java;Computer bugs;Production;Tools;Maintenance engineering;Software systems;Distance measurement","","4","","29","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"On the Effectiveness of Deep Vulnerability Detectors to Simple Stupid Bug Detection","J. Hua; H. Wang","School of Computer Science, Beijing University of Posts and Telecommunications, Beijing, China; School of Computer Science, Beijing University of Posts and Telecommunications, Beijing, China",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","530","534","Recent studies have shown the promising direction of deep learning based bug detection, which relieves human experts from the tedious and subjective task of manually summarizing features. Simple one-statement bugs (i.e., SStuBs), which occur relatively often in Java projects, cannot be well spotted by existing static analysis tools. In this paper, we make effort to empirically analyze whether deep learning based techniques could be used to detecting SStuBs. We have re-implemented two state-of-the-art techniques in approximately 3,000 lines of code and adopted them to detecting Java SStuBs. Experiments on large-scale datasets suggest that although deep vulnerability detectors can achieve much better results than existing static analyzers, the SStuBs cannot be well flagged when comparing with traditional complex vulnerabilities. We further look in detail on the per bug category basis, observing that deep learning based methods perform better when detecting some specific types of bugs (e.g., ""Same Function Change Caller""), which have strong data flow and control flow semantic. Our observations could offer implications on the automated detection and repair of SStuBs.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00068","National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463107","bug detection;deep learning;simple stupid bugs","Deep learning;Java;Computer bugs;Semantics;Detectors;Static analysis;Tools","","4","","22","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"AndroidCompass: A Dataset of Android Compatibility Checks in Code Repositories","S. Nielebock; P. Blockhaus; J. Krüger; F. Ortmeier","Otto-von-Guericke University, Magdeburg, Germany; Otto-von-Guericke University, Magdeburg, Germany; Otto-von-Guericke University, Magdeburg, Germany; Otto-von-Guericke University, Magdeburg, Germany",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","535","539","Many developers and organizations implement apps for Android, the most widely used operating system for mobile devices. Common problems developers face are the various hardware devices, customized Android variants, and frequent updates, forcing them to implement workarounds for the different versions and variants of Android APIs used in practice. In this paper, we contribute the Android Compatibility checkS dataSet (AndroidCompass) that comprises changes to compatibility checks developers use to enforce workarounds for specific Android versions in their apps. We extracted 80,324 changes to compatibility checks from 1,394 apps by analyzing the version histories of 2,399 projects from the F-Droid catalog. With AndroidCompass, we aim to provide data on when and how developers introduced or evolved workarounds to handle Android incompatibilities. We hope that AndroidCompass fosters research to deal with version incompatibilities, address potential design flaws, identify security concerns, and help derive solutions for other developers, among others—helping researchers to develop and evaluate novel techniques, and Android app as well as operating-system developers in engineering their software.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00069","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463151","Android;compatibility;API;dataset","Fault diagnosis;Operating systems;Organizations;Maintenance engineering;Tools;Software;Mobile handsets","","7","","24","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Denchmark: A Bug Benchmark of Deep Learning-related Software","M. Kim; Y. Kim; E. Lee","Department of Electrical and Computer Engineering, Sungkyunkwan University, Suwon, Republic of Korea; Department of Electrical and Computer Engineering, Sungkyunkwan University, Suwon, Republic of Korea; College of Computing, Sungkyunkwan University, Suwon, Republic of Korea",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","540","544","A growing interest in deep learning (DL) has instigated a concomitant rise in DL-related software (DLSW). Therefore, the importance of DLSW quality has emerged as a vital issue. Simultaneously, researchers have found DLSW more complicated than traditional SW and more difficult to debug owing to the black-box nature of DL. These studies indicate the necessity of automatic debugging techniques for DLSW. Although several validated debugging techniques exist for general SW, no such techniques exist for DLSW. There is no standard bug benchmark to validate these automatic debugging techniques. In this study, we introduce a novel bug benchmark for DLSW, Denchmark, consisting of 4,577 bug reports from 193 popular DLSW projects, collected through a systematic dataset construction process. These DLSW projects are further classified into eight categories: framework, platform, engine, compiler, tool, library, DL-based application, and others. All bug reports in Denchmark contain rich textual information and links with bug-fixing commits, as well as three levels of buggy entities, such as files, methods, and lines. Our dataset aims to provide an invaluable starting point for the automatic debugging techniques of DLSW.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00070","National Research Foundation of Korea; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463133","Automatic debugging;Bug report;Bug Bench-mark;Deep learning-related software","Deep learning;Systematics;Computer bugs;Debugging;Benchmark testing;Tools;Software","","7","","32","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Duets: A Dataset of Reproducible Pairs of Java Library-Clients","T. Durieux; C. Soto-Valero; B. Baudry","KTH Royal Institute of Technology, Stockholm, Sweden; KTH Royal Institute of Technology, Stockholm, Sweden; KTH Royal Institute of Technology, Stockholm, Sweden",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","545","549","Software engineering researchers look for software artifacts to study their characteristics or to evaluate new techniques. In this paper, we introduce Duets, a new dataset of software libraries and their clients. This dataset can be exploited to gain many different insights, such as API usage, usage inputs, or novel observations about the test suites of clients and libraries. Duets is meant to support both static and dynamic analysis. This means that the libraries and the clients compile correctly, they are executable and their test suites pass. The dataset is composed of open-source projects that have more than five stars on GitHub. The final dataset contains 395 libraries and 2,874 clients. Additionally, we provide the raw data that we use to create this dataset, such as 34,560 pom.xml files or the complete file list from 34,560 projects. This dataset can be used to study how libraries are used by their clients or as a list of software projects that successfully build. The client’s test suite can be used as an additional verification step for code transformation techniques that modify the libraries.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00071","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463096","Mining software repositories;software reuse;Java;Maven","Java;Software libraries;Ecosystems;Static analysis;Tools;Libraries;Data mining","","9","","31","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"KGTorrent: A Dataset of Python Jupyter Notebooks from Kaggle","L. Quaranta; F. Calefato; F. Lanubile","University of Bari, Italy; University of Bari, Italy; University of Bari, Italy",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","550","554","Computational notebooks have become the tool of choice for many data scientists and practitioners for performing analyses and disseminating results. Despite their increasing popularity, the research community cannot yet count on a large, curated dataset of computational notebooks. In this paper, we fill this gap by introducing KGTorrent, a dataset of Python Jupyter notebooks with rich metadata retrieved from Kaggle, a platform hosting data science competitions for learners and practitioners with any levels of expertise. We describe how we built KGTorrent, and provide instructions on how to use it and refresh the collection to keep it up to date. Our vision is that the research community will use KGTorrent to study how data scientists, especially practitioners, use Jupyter Notebook in the wild and identify potential shortcomings to inform the design of its future extensions.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00072","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463068","open dataset;repository;Kaggle;computational notebook;Jupyter","Tools;Metadata;Data science;Software;Data mining;Python","","42","","14","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"A Traceability Dataset for Open Source Systems","M. Hammoudi; C. Mayr-Dorn; A. Mashkoor; A. Egyed","Johannes Kepler University, Linz, Austria; Johannes Kepler University, Linz, Austria; Johannes Kepler University, Linz, Austria; Johannes Kepler University, Linz, Austria",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","555","559","Software engineers use requirement-to-method trace matrices to indicate the methods implementing different system requirements. Requirement-to-method trace matrices pinpoint the exact method implementing each requirement, which facilitates software maintenance and bug fixing. The code structure of a system can be used to make predictions about requirement-to-method traces. In this paper, we present a data set documenting the requirement-to-method traces as well as the code structure (methods, variables, etc.) for four open source systems. The code structure was obtained by parsing the systems under consideration and extracting the methods, variables, etc. The requirement-to-method trace matrices were obtained by resorting to students as well as to the original developers of the systems who provided us with the list of requirement-to-method traces.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00073","Austrian Science Fund; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463088","","Software maintenance;Computer bugs;Data mining;Software engineering","","3","","18","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Sampling Projects in GitHub for MSR Studies","O. Dabic; E. Aghajani; G. Bavota","SEART @ Software Institute, USI Università della Svizzera italiana, Lugano, Switzerland; SEART @ Software Institute, USI Università della Svizzera italiana, Lugano, Switzerland; SEART @ Software Institute, USI Università della Svizzera italiana, Lugano, Switzerland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","560","564","Almost every Mining Software Repositories (MSR) study requires, as first step, the selection of the subject software repositories. These repositories are usually collected from hosting services like GitHub using specific selection criteria dictated by the study goal. For example, a study related to licensing might be interested in selecting projects explicitly declaring a license. Once the selection criteria have been defined, utilities such as the GitHub APIs can be used to ""query"" the hosting service. However, researchers have to deal with usage limitations imposed by these APIs and a lack of required information. For example, the GitHub search APIs allow 30 requests per minute and, when searching repositories, only provide limited information (e.g., the number of commits in a repository is not included). To support researchers in sampling projects from GitHub, we present GHS (GitHub Search), a dataset containing 25 characteristics (e.g., number of commits, license, etc.) of 735,669 repositories written in 10 programming languages. The set of characteristics has been derived by looking for frequently used project selection criteria in MSR studies and the dataset is continuously updated to (i) always provide fresh data about the existing projects, and (ii) increase the number of indexed projects. The GHS dataset can be queried through a web application we built that allows to set many combinations of selection criteria needed for a study and download the information of matching repositories: https://seart-ghs.si.usi.ch.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00074","European Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463094","GitHub;search;sampling repositories","Computer languages;Licenses;Software;Data mining;Software development management","","103","","39","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"The Wonderless Dataset for Serverless Computing","N. Eskandani; G. Salvaneschi","Technische Universität Darmstadt, Germany; University of St. Gallen, Switzerland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","565","569","Function as a Service (FaaS) has grown in popularity in recent years, with an increasing number of applications following the Serverless computing model. Serverless computing supports out of the box autoscaling in a pay-as-you-go manner, letting developers focus on the application logic rather than worrying about resource management. With the increasing adoption of the this model, researchers have started studying a wide variety of aspects of Serverless computing, including communication, security, performance, and cost optimization. Yet, we still know very little of how Serverless computing is used in practice.In this paper, we introduce Wonderless, a novel dataset of open-source Serverless applications. Wonderless consists of 1,877 real-world Serverless applications extracted from GitHub, and it can be used as a data source for further research in the Serverless ecosystem, such as performance evaluation and software mining. To the best of our knowledge, Wonderless is currently the most diverse and largest dataset for research on Serverless computing.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00075","EWE; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463099","FaaS;Function as a Service;Serverless;Cloud Computing","Performance evaluation;Computational modeling;Ecosystems;FAA;Data mining;Security;Resource management","","10","","30","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"AndroCT: Ten Years of App Call Traces in Android","W. Li; X. Fu; H. Cai","Washington State University, USA; Washington State University, USA; Washington State University, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","570","574","Data-driven approaches have proven to be promising in mobile software analysis, yet these approaches rely on sizable and quality datasets. For Android app analysis in particular, there have been several well-known datasets that are widely used by the community. However, there is still a lack of such datasets that represent the run-time behaviors of apps— existing datasets are largely static, whereas run-time datasets are essential for data-driven dynamic and hybrid analysis of apps. In this paper, we present AndroCT, a large-scale dataset on the run-time traces of function calls in 35,974 benign and malicious Android apps from ten historical years (2010 through 2019). These call traces were produced by running each sample app against automatically generated test inputs for ten minutes. Moreover, each app was exercised both on an emulator and a real device, and the traces were separately curated. AndroCT has been used to build a novel dynamic profile of Android apps that has enabled several effective techniques and informative empirical studies concerning Android app security. We describe what this dataset includes, how it was created and stored, and how it has been used in past and would be used in the future.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00076","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463081","Android apps;dataset;function calls;tracing","Software;Security;Data mining","","17","","30","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Search4Code: Code Search Intent Classification Using Weak Supervision","N. Rao; C. Bansal; J. Guan",Microsoft Research; Microsoft Research; Microsoft,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","575","579","Developers use search for various tasks such as finding code, documentation, debugging information, etc. In particular, web search is heavily used by developers for finding code examples and snippets during the coding process. Recently, natural language based code search has been an active area of research. However, the lack of real-world large-scale datasets is a significant bottleneck. In this work, we propose a weak supervision based approach for detecting code search intent in search queries for C# and Java programming languages. We evaluate the approach against several baselines on a real-world dataset comprised of over 1 million queries mined from Bing web search engine and show that the CNN based model can achieve an accuracy of 77% and 76% for C# and Java respectively. Furthermore, we are also releasing Search4Code, the first large-scale real-world dataset of code search queries mined from Bing web search engine. We hope that the dataset will aid future research on code search.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00077","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463144","code search;weak supervision","Java;Natural languages;Documentation;Debugging;Software;Encoding;C# languages","","7","","30","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Andromeda: A Dataset of Ansible Galaxy Roles and Their Evolution","R. Opdebeeck; A. Zerouali; C. De Roover","Vrije Universiteit Brussel, Brussels, Belgium; Vrije Universiteit Brussel, Brussels, Belgium; Vrije Universiteit Brussel, Brussels, Belgium",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","580","584","Cloud-native applications increasingly provision infrastructure resources programmatically through Infrastructure as Code (IaC) scripts. These scripts have in turn become the subject of empirical software engineering research. However, an often-overlooked part are the software ecosystems that have grown around the IaC languages. For example, Galaxy is an ecosystem for the popular Ansible IaC language. Galaxy features a large number of so-called ""roles"", which are reusable collections of Ansible code akin to libraries for general-purpose languages. In contrast to, and despite their similarities, such IaC ecosystems have enjoyed far less attention in the literature than library ecosystems for general-purpose languages.In this data showcase paper, we present Andromeda, the first dataset capturing the Ansible Galaxy ecosystem, its roles, and their evolution. Andromeda provides structural representations of more than 125 000 role versions, and upwards of 800 000 concrete changes between such versions extracted from the underlying git repositories. Andromeda aims to provide an extensive view of the contributor side of the Galaxy ecosystem, which we hope will stimulate additional research on IaC ecosystems.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00078","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463065","Infrastructure as Code;dataset;mining software repositories;change distilling;Ansible","Ecosystems;Metadata;Software;Libraries;Data mining;Software engineering","","11","","11","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"ManyTypes4Py: A Benchmark Python Dataset for Machine Learning-based Type Inference","A. M. Mir; E. Latoškinas; G. Gousios","Department of Software Technology, Delft University of Technology, Delft, The Netherlands; Department of Software Technology, Delft University of Technology, Delft, The Netherlands; Department of Software Technology, Delft University of Technology, Delft, The Netherlands",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","585","589","In this paper, we present ManyTypes4Py, a large Python dataset for machine learning (ML)-based type inference. The dataset contains a total of 5,382 Python projects with more than 869K type annotations. Duplicate source code files were removed to eliminate the negative effect of the duplication bias. To facilitate training and evaluation of ML models, the dataset was split into training, validation and test sets by files. To extract type information from abstract syntax trees (ASTs), a light-weight static analyzer pipeline is developed and accompanied with the dataset. Using this pipeline, the collected Python projects were analyzed and the results of the AST analysis were stored in JSON-formatted files. The ManyTypes4Py dataset is shared on zenodo and its tools are publicly available on GitHub.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00079","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463150","Type Inference;Machine Learning;Python;Type Annotations;Static Analysis","Training;Analytical models;Annotations;Pipelines;Tools;Benchmark testing;Syntactics","","16","","16","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"QScored: A Large Dataset of Code Smells and Quality Metrics","T. Sharma; M. Kessentini","Siemens Technology, Charlotte, USA; University of Michigan, MI, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","590","594","Code quality aspects such as code smells and code quality metrics are widely used in exploratory and empirical software engineering research. In such studies, researchers spend a substantial amount of time and effort to not only select the appropriate subject systems but also to analyze them to collect the required code quality information. In this paper, we present QScored dataset; the dataset contains code quality information of more than 86 thousand C# and Java GitHub repositories containing more than 1.1 billion lines of code. The code quality information contains seven kinds of detected architecture smells, 20 kinds of design smells, eleven kinds of implementation smells, and 27 commonly used code quality metrics computed at project, package, class, and method levels. Availability of the dataset will facilitate empirical studies involving code quality aspects by making the information readily available for a large number of active GitHub repositories.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00080","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463095","Code quality;code smells;quality metrics;maintainability;technical debt","Measurement;Java;Computer architecture;Software;C# languages;Data mining;Software development management","","9","","27","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Apache Software Foundation Incubator Project Sustainability Dataset","L. Yin; Z. Zhang; Q. Xuan; V. Filkov",UC Davis; UC Davis; Zhejiang University of Technology; UC Davis,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","595","599","Open Source Software success and sustainability is critically important for the digital infrastructure as OSS is used broadly and yet 83+% of such projects fail. To increase chances of success many projects join established software communities, e.g. the Apache Software Foundation (ASF), with clearly established rules and support. Specifically at ASF, projects that strive to join ASF and are at a nascent development stage are digitally housed in the ASF incubator (ASFI), which provides a mature governance environment and expert help toward long-term sustainability. Projects in ASFI eventually conclude their incubation by graduating, if successful on the path to sustainability. Otherwise, they get retired. In ASF, digital traces of developer activities for projects in ASFI are publicly available, together with monthly project status.Here we present a longitudinal dataset of developer coding and communication activities of 269 projects from the Apache Software Foundation Incubator (ASFI). Each project in ASFI is evaluated while in incubation and is eventually ""graduated"" or ""retired"", a label indicating the project sustainability promise with respect to their technical development and community diversity. This extrinsically labeled dataset offers heretofore unavailable sustainability data of OSS project development under ASF regulations and governance. We hope its availability will foster more research interest in studying sustainability in OSS projects.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00081","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463075","Apache Software Foundation;OSS Projects;Incubator","Regulation;Encoding;Data mining;Sustainable development;Open source software","","9","","21","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Andror2: A Dataset of Manually-Reproduced Bug Reports for Android apps","T. Wendland; J. Sun; J. Mahmud; S. M. H. Mansur; S. Huang; K. Moran; J. Rubin; M. Fazzini","University of Minnesota, MN, USA; University of Bristish Columbia, Canada; George Mason University, VA, USA; George Mason University, VA, USA; University of Bristish Columbia, Canada; George Mason University, VA, USA; University of Bristish Columbia, Canada; University of Minnesota, MN, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","600","604","Software maintenance constitutes a large portion of the software development lifecycle. To carry out maintenance tasks, developers often need to understand and reproduce bug reports. As such, there has been increasing research activity coalescing around the notion of automating various activities related to bug reporting. A sizable portion of this research interest has focused on the domain of mobile apps. However, as research around mobile app bug reporting progresses, there is a clear need for a manually vetted and reproducible set of real-world bug reports that can serve as a benchmark for future work. This paper presents AndroR2: a dataset of 90 manually reproduced bug reports for Android apps listed on Google Play and hosted on GitHub, systematically collected via an in-depth analysis of 459 reports extracted from the GitHub issue tracker. For each reproduced report, AndroR2 includes the original bug report, an apk file for the buggy version of the app, an executable reproduction script, and metadata regarding the quality of the reproduction steps associated with the original report. We believe that the AndroR2 dataset can be used to facilitate research in automatically analyzing, understanding, reproducing, localizing, and fixing bugs for mobile applications as well as other software maintenance activities more broadly.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00082","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463119","Bug reports;mobile apps.;software maintenance","Software testing;Software maintenance;Computer bugs;Manuals;Metadata;Maintenance engineering;Mobile applications","","18","","34","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"GE526: A Dataset of Open-Source Game Engines","D. Vagavolu; V. Agrahari; S. Chimalakonda; A. S. M. Venigalla","Department of Computer Science and Engineering, Indian Institute of Technology Tirupati, Tirupati, India; Department of Computer Science and Engineering, Indian Institute of Technology Tirupati, Tirupati, India; Department of Computer Science and Engineering, Indian Institute of Technology Tirupati, Tirupati, India; Department of Computer Science and Engineering, Indian Institute of Technology Tirupati, Tirupati, India",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","605","609","Game engines, are frameworks that provide a platform for developers to build games with an interface tailored to handle the complexity of game development. Though there is extensive empirical research on software frameworks, there is a need for empirical studies on game engines, as they differ from traditional software frameworks. Thus, to aid research and development in the area of game engines, we present GE526, a curated dataset of 526 game engine repositories mined from GitHub, which can help researchers to analyze game engines in terms of the release cycles, code quality, API usability and so on. To the best of our knowledge, we are not aware of any curated dataset that caters to game engines in the literature. The dataset contains metadata of all the mined repositories, including 582,079 commits, 20,138 pull requests, 30,287 issues reports and 2,111 releases. The dataset along with its documentation is made available at - https://bit.ly/3pyexnc.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00083","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463127","Game Engine;Dataset;Open Source","Games;Documentation;Metadata;Tools;Data mining;Usability;Engines","","1","","23","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"EqBench: A Dataset of Equivalent and Non-equivalent Program Pairs","S. Badihi; Y. Li; J. Rubin","Univ. of British Columbia, Canada; Nanyang Technological University, Singapore; Univ. of British Columbia, Canada",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","610","614","Equivalence checking techniques help establish whether two versions of a program exhibit the same behavior. The majority of popular techniques for formally proving/refuting equivalence are evaluated on small and simplistic benchmarks, omitting ""difficult"" programming constructs, such as non-linear arithmetic, loops, floating-point arithmetic, and string and array manipulation. This hinders efficient evaluation of these techniques and the ability to establish their practical applicability in real scenarios. This paper addresses this gap by contributing EqBench - the largest and most comprehensive benchmark for equivalence checking analysis, which contains 147 equivalent and 125 non-equivalent cases, in both C and Java languages. We believe EqBench can facilitate a more realistic evaluation of equivalence checking techniques, assessing their individual strength and weaknesses. EqBench is publicly available at: https://osf.io/93s5b/.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00084","Ministry of Education; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463140","Equivalence checking;benchmark;Java;C.","Java;Computer languages;Benchmark testing;Tools;Programming;Software;Data mining","","4","","27","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Tracking Hackathon Code Creation and Reuse","A. Imam; T. Dey","University of Tartu, Estonia; Lero—the Irish Software Research Centre, University of Limerick, Limerick, Ireland",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","615","617","Background: Hackathons have become popular events for teams to collaborate on projects and develop software prototypes. Most existing research focuses on activities during an event with limited attention to the evolution of the code brought to or created during a hackathon. Aim: We aim to understand the evolution of hackathon-related code, specifically, how much hackathon teams rely on pre-existing code or how much new code they develop during a hackathon. Moreover, we aim to understand if and where that code gets reused. Method: We collected information about 22,183 hackathon projects from Devpost– a hackathon database – and obtained related code (blobs), authors, and project characteristics from the World of Code. We investigated if code blobs in hackathon projects were created before, during, or after an event by identifying the original blob creation date and author, and also checked if the original author was a hackathon project member. We tracked code reuse by first identifying all commits containing blobs created during an event before determining all projects that contain those commits. Result: While only approximately 9.14% of the code blobs are created during hackathons, this amount is still significant considering time and member constraints of such events. Approximately a third of these code blobs get reused in other projects. Conclusion: Our study demonstrates to what extent pre-existing code is used and new code is created during a hackathon and how much of it is reused elsewhere afterwards. Our findings help to better understand code reuse as a phenomenon and the role of hackathons in this context and can serve as a starting point for further studies in this area.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00085","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463076","Hackathon;Code Reuse;Repository Mining;Commits;Blob Reuse","Databases;Prototypes;Software;Time factors;Data mining","","3","","19","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Building the Collaboration Graph of Open-Source Software Ecosystem","E. Lyulina; M. Jahanshahi","JetBrains Research, Saint Petersburg, Russia; Babol, Iran",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","618","620","The Open-Source Software community has become the center of attention for many researchers, who are investigating various aspects of collaboration in this extremely large ecosystem. Due to its size, it is difficult to grasp whether or not it has structure, and if so, what it may be. Our hackathon project aims to facilitate the understanding of the developer collaboration structure and relationships among projects based on the bi-graph of what projects developers contribute to by providing an interactive collaboration graph of this ecosystem, using the data obtained from World of Code [1] infrastructure. Our attempts to visualize the entirety of projects and developers were stymied by the inability of the layout and visualization tools to process the exceedingly large scale of the full graph. We used WoC to filter the nodes (developers and projects) and edges (developer contributions to a project) to reduce the scale of the graph that made it amenable to an interactive visualization and published the resulting visualizations. We plan to apply hierarchical approaches to be able to incorporate the entire data in the interactive visualizations and also to evaluate the utility of such visualizations for several tasks.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00086","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463070","social networks;world of code;open source software","Ecosystems;Layout;Buildings;Data visualization;Collaboration;Tools;Data mining","","3","","10","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Tracing Vulnerable Code Lineage","D. Reid; K. Eng; C. Bogart; A. Tutko","Department of EECS, University of Tennessee, Knoxville, USA; Department of Computing Science, University of Alberta, Edmonton, Canada; Institute for Software Research, Carnegie Mellon University, Pittsburgh, USA; Department of EECS, University of Tennessee, Knoxville, USA",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","621","623","This paper presents results from the MSR 2021 Hackathon. Our team investigates files/projects that contain known security vulnerabilities and how widespread they are throughout repositories in open source software. These security vulnerabilities can potentially be propagated through code reuse even when the vulnerability is fixed in different versions of the code. We utilize the World of Code [1] infrastructure to discover file-level duplication of code from a nearly complete collection of open source software. This paper describes a method and set of tools to find all open source projects that use known vulnerable files and any previous revisions of those files.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00087","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463067","Github;CVE;Security","Tools;Security;Data mining;Open source software","","2","","8","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"An Exploratory Study of Project Activity Changepoints in Open Source Software Evolution","J. Walden; N. Burgin; K. Kaur","Department of Computer Science, Northern Kentucky University, Highland Heights, KY, USA; Department of EE and Computer Science, University of Tennessee, Knoxville, TN, USA; Department of Computer Science, Guru Nanak Dev University, Amritsar, India",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","624","626","To explore the prevalence of abrupt changes (changepoints) in open source project activity, we assembled a dataset of 8,919 projects from the World of Code. Projects were selected based on age, number of commits, and number of authors. Using the nonparametric PELT algorithm, we identified changepoints in project activity time series, finding that more than 90% of projects had between one and six changepoints. Increases and decreases in project activity occurred with roughly equal frequency. While most changes are relatively small, on the order of a few authors or few dozen commits per month, there were long tails of much larger project activity changes. In future work, we plan to focus on larger changes to search for common open source lifecycle patterns as well as common responses to external events.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00088","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463069","software evolution;changepoints;world of code","Time series analysis;Data models;Complexity theory;Security;Data mining;Open source software","","","","7","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"The Diversity-Innovation Paradox in Open-Source Software","M. S. Yong; L. Paganini; H. S. Qiu; J. B. Santiago Calderón","School of Computer Science, Carnegie Mellon University; Centro de Informática, Federal University of Pernambuco, Brazil; School of Computer Science, Carnegie Mellon University; Biocomplexity Institute & Initiative, University of Virginia",2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","627","629","Prior studies have shown that, in open-source software (OSS), diversity is a positive indicator of productivity. Yet, code submissions from underrepresented groups are less successful. This mirrors the diversity-innovation paradox found in science—diverse groups produce more innovations, but historically underrepresented people have less successful careers in these groups. In this preliminary research, we want to investigate whether the effect of the diversity-innovation paradox is present in OSS. We define software innovation as a novel co-usage of two packages in the same project. Using World of Code, we identified JavaScript projects’ innovations from late 2008 to early 2014. We intend to calculate diversity measures for the authors who produced the innovations and build models to test the presence of the diversity-innovation paradox in OSS.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00089","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463124","open-source;innovation;diversity","Productivity;Technological innovation;Engineering profession;Mirrors;Data mining;Open source software","","","","11","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
"Author Index","",,2021 IEEE/ACM 18th International Conference on Mining Software Repositories (MSR),"28 Jun 2021","2021","","","631","634","Presents an index of the authors whose articles are published in the conference proceedings record.","2574-3864","978-1-7281-8710-5","10.1109/MSR52588.2021.00090","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9463139","","","","","","","IEEE","28 Jun 2021","","","IEEE","IEEE Conferences"
